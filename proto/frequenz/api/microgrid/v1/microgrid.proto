// protolint:disable MAX_LINE_LENGTH

// Frequenz Microgrid API
//
// Copyright:
// Copyright 2022 Frequenz Energy-as-a-Service GmbH
//
// License:
// MIT

syntax = "proto3";

package frequenz.api.microgrid.v1;

import "frequenz/api/common/v1/location.proto";
import "frequenz/api/common/v1/metrics/bounds.proto";
import "frequenz/api/common/v1/metrics/metric_sample.proto";
import "frequenz/api/common/v1/microgrid/components/components.proto";
import "frequenz/api/common/v1/microgrid/microgrid.proto";
import "frequenz/api/common/v1/microgrid/sensors/sensors.proto";

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

// The Frequenz Microgrid API
service Microgrid {
  // Returns the microgrid metadata
  // The metadata consists of information that describes the overall
  // microgrid, as opposed to its electrical components or sensors,
  // e.g., the microgrid ID, location.
  rpc GetMicrogridMetadata(google.protobuf.Empty)
    returns (GetMicrogridMetadataResponse) {
    option (google.api.http) = {
      get : "/v1/metadata"
    };
  }

  // List electrical components in the local microgrid, optionally filtered by a
  // given list of component IDs and component categories.
  //
  // Electrical components are a part of a microgrid's electrical infrastructure
  // are can be connected to each other to form an electrical circuit, which can
  // then be represented as a graph.
  //
  // If provided, the filters for component IDs and categories have an `AND`
  // relationship with one another, meaning that they are applied serially,
  // but the elements within a single filter list have an `OR` relationship with
  // each other.
  // E.g., if `ids` = [1, 2, 3], and `categories` = [
  //  `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,
  //  `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],
  // then the results will consist of elements that
  // have the IDs 1, OR 2, OR 3,
  // AND
  // are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR
  // `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.
  //
  // If a filter list is empty, then that filter is not applied.
  rpc ListComponents(ListComponentsRequest) returns (ListComponentsResponse) {
    option (google.api.http) = {
      get : "/v1/components"
    };
  }

  // Returns a list of sensors in the local microgrid, optionally filtered by a
  // given list of sensor IDs and sensor categories.
  //
  // Sensors measure physical metrics in the microgrid's surroundings, and are
  // not classified as electrical components.
  //
  // If provided, the filters for sensor IDs and categories have an `AND`
  // relationship with one another, meaning that they are applied serially,
  // but the elements within a single filter list have an `OR` relationship with
  // each other.
  // E.g., if `ids` = [1, 2, 3], and `categories` = [
  //  `SensorCategory::SENSOR_CATEGORY_THERMOMETER`,
  //  `SensorCategory::SENSOR_CATEGORY_HYGROMETER`],
  // then the results will consist of elements that
  // have the IDs 1, OR 2, OR 3,
  // AND
  // are of the categories `SensorCategory::SENSOR_CATEGORY_THERMOMETER` OR
  // `SensorCategory::SENSOR_CATEGORY_HYGROMETER`.
  //
  // If a filter list is empty, then that filter is not applied.
  rpc ListSensors(ListSensorRequest) returns (ListSensorsResponse) {
    option (google.api.http) = {
      get : "/v1/sensors"
    };
  }

  // Electrical components are a part of a microgrid's electrical infrastructure
  // are can be connected to each other to form an electrical circuit, which can
  // then be represented as a graph.
  //
  // This RPC return a list of the connections between two components, denoted
  // by `(start, end)`. The direction of a connection is always away from the
  // grid endpoint, i.e. aligned with the direction of positive current
  // according to the passive sign convention:
  // https://en.wikipedia.org/wiki/Passive_sign_convention
  //
  // The request may be filtered by `start`/`end` component(s) of individual
  // connections.  If provided, the `start` and `end` filters have an `AND`
  // relationship between each other, meaning that they are applied serially,
  // but an `OR` relationship with other elements in the same list.
  // For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the
  // result should have all the connections where
  // * each `start` component ID is either `1`, `2`, OR `3`,
  //  AND
  // * each `end` component ID is either `4`, `5`, OR `6`.
  rpc ListConnections(ListConnectionsRequest)
    returns (ListConnectionsResponse) {
    option (google.api.http) = {
      get : "/v1/connections"
    };
  }

  // Returns a stream containing data from a component with a given ID.
  rpc ReceiveComponentDataStream(ReceiveComponentDataStreamRequest)
    returns (stream ReceiveComponentDataStreamResponse) {
    option (google.api.http) = {
      get : "/v1/components/{id}/data"
    };
  }

  // Returns a stream containing data from a sensor with a given ID.
  rpc ReceiveSensorDataStream(ReceiveSensorDataStreamRequest)
    returns (stream ReceiveSensorDataStreamResponse) {
    option (google.api.http) = {
      get : "/v1/sensors/{id}/data"
    };
  }

  // Adds exclusion bounds for a given metric of a given component, and returns
  // the UTC timestamp until which the given exclusion bounds will stay in
  // effect.
  //
  // Exclusion bounds refer to the range of values that are disallowed for the
  // metric. If these bounds for a metric are [`lower`, `upper`], then this
  // metric's `value` needs to comply with the constraints
  // `value <= lower` OR `upper <= value`.
  //
  // Exclusion bounds are a useful tool for enhancing the performance of a
  // system. They can be used to restrict the acceptance of commands that fall
  // below a certain threshold, which can help ensure the smooth functioning of
  // the system.
  // E.g., exclusion bounds can be set to limit the minimum charging power to a
  // sufficiently high level, preventing a peak-shaver client from sending
  // charge powers that are too low when a DC heater client is executing a
  // charge pulse. This can significantly improve the overall performance of the
  // DC heating mechanism.
  //
  //
  // If multiple exclusion bounds have been provided bor a metric, then the
  // aggregated lower and upper exclusion bounds are calculated as follows:
  // lower: the minimum of all lower exclusion bounds
  // upper: the maximum of all upper exclusion bounds
  //
  // It is important to note that these bounds work together with
  // `system_inclusion_bounds`.
  //
  // E.g., for the system to accept a charge command,
  // clients need to request power values within the bounds
  // `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
  // This means that clients can only request charge commands with values that
  // are within the `system_inclusion_bounds`, but not within
  // `system_exclusion_bounds`.
  // Similarly, for the system to accept a discharge command,
  // clients need to request power values within the bounds
  // `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.
  //
  // The following diagram illustrates the relationship between the bounds.
  // ```
  //   inclusion.lower                              inclusion.upper
  // <-------|============|------------------|============|--------->
  //                exclusion.lower    exclusion.upper
  // ```
  // ---- values here are disallowed and will be rejected
  // ==== vales here are allowed and will be accepted
  rpc AddComponentExclusionBounds(AddComponentExclusionBoundsRequest)
    returns (AddComponentExclusionBoundsResponse);

  // Adds inclusion bounds for a given metric of a given component, and returns
  // the UTC timestamp until which the given inclusion bounds will stay in
  // effect.
  //
  // Inclusion bounds refer to the range of values that are allowed for the
  // metric. If these bounds for a metric are [`lower`, `upper`], then this
  // metric's `value` needs to comply with the constraint
  // `lower <= value <= upper`.
  //
  // If multiple inclusion bounds have been provided bor a metric, then the
  // aggregated lower and upper inclusion bounds are calculated as follows:
  // lower: the maximum of all lower inclusion bounds
  // upper: the minimum of all upper inclusion bounds
  //
  // It is important to note that these bounds work together with
  // `system_exclusion_bounds`.
  //
  // E.g., for the system to accept a charge command,
  // clients need to request power values within the bounds
  // `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
  // This means that clients can only request charge commands with values that
  // are within the `system_inclusion_bounds`, but not within
  // `system_exclusion_bounds`.
  // Similarly, for the system to accept a discharge command,
  // clients need to request power values within the bounds
  // `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.
  //
  // The following diagram illustrates the relationship between the bounds.
  // ```
  //   inclusion.lower                              inclusion.upper
  // <-------|============|------------------|============|--------->
  //                exclusion.lower    exclusion.upper
  // ```
  // ---- values here are disallowed and will be rejected
  // ==== vales here are allowed and will be accepted
  rpc AddComponentInclusionBounds(AddComponentInclusionBoundsRequest)
    returns (AddComponentInclusionBoundsResponse);

  // Sets the active power output of a component with a given ID, provided the
  // component supports it. The power output is specified in watts.
  //
  // The power output can be -ve or +ve, depending on whether the component is
  // supposed to be discharging or charging, respectively.
  //
  // The return value is the timestamp until which the given power command will
  // stay in effect. After this timestamp, the component's active power will be
  // set to 0, if the API receives no further command to change it before then.
  // By default, this timestamp will be set to the current time plus 60 seconds.
  //
  // Note that the target component may have a resolution of more than 1 W.
  // E.g., an inverter may have a resolution of 88 W.
  // In such cases, the magnitude of power will be floored to the nearest
  // multiple of the resolution.
  //
  // Performs the following sequence actions for the following component
  // categories:
  //
  // * Inverter: Sends the discharge command to the inverter, making it deliver
  //  AC power.
  rpc SetComponentPowerActive(SetComponentPowerActiveRequest)
    returns (SetComponentPowerActiveResponse) {
    option (google.api.http) = {
      get : "/v1/components/{component_id}/setPowerActive/{power}"
    };
  }

  // Sets the reactive power output of a component with a given ID, provided the
  // component supports it. The power output is specified in VAr.
  //
  // The power output can be -ve or +ve, depending on whether the component is
  // supposed to be delivering inductive or capacitive power, respectively.
  //
  // The return value is the timestamp until which the given power command will
  // stay in effect. After this timestamp, the component's reactive power will
  // be set to 0, if the API receives no further command to change it before
  // then.
  // By default, this timestamp will be set to the current time plus 60 seconds.
  //
  // Note that the target component may have a resolution of more than 1 VAr.
  // E.g., an inverter may have a resolution of 88 VAr.
  // In such cases, the magnitude of power will be floored to the nearest
  // multiple of the resolution.
  rpc SetComponentPowerReactive(SetComponentPowerReactiveRequest)
    returns (SetComponentPowerReactiveResponse) {
    option (google.api.http) = {
      get : "/v1/components/{component_id}/setPowerReactive/{power}"
    };
  }

  // Starts the component, and brings it into a state where it is immediately
  // operational.
  //
  // Performs the following sequence of actions for the following component
  // categories:
  //
  // * Inverter:
  //  * closes DC relays, if the feature is available
  //  * closes AC relays
  //  * sets power output to 0
  //
  // * Battery: Checks if DC relays are open, then
  //  * closes DC relays
  //
  // * Relays:
  //  * closes relays
  //
  // * Precharge Modules:
  //  * starts the precharge process, and eventually closes the DC relays.
  //
  // If any of the above mentioned actions for a given component has already
  // been performed, then this method call effectively skips that action.
  //
  // If a feature required to perform an action is missing, then that action is
  // skipped.
  rpc StartComponent(StartComponentRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      get : "/v1/components/{id}/start"
    };
  }

  // Sets the given component into a standby state, from which it can take a
  // few minutes to return to an operational state. A transition to an
  // operational state can be triggered by calling the `StartComponent` RPC, or
  // the `SetComponentPowerActive` RPC.
  //
  // Performs the following sequence actions for the following component
  // categories:
  //
  // * Inverter: Checks if AC and DC relays are closed, then
  //  * sets power to 0, and
  //  * opens AC relays
  //
  // If any of the checks mentioned above fails, then the method call returns an
  // error.
  //
  // If any of the above mentioned actions for a given component has already
  // been performed, then this method call efffectively skips that action.
  rpc PutComponentInStandby(PutComponentInStandbyRequest)
    returns (google.protobuf.Empty) {
    option (google.api.http) = {
      get : "/v1/components/{id}/standby"
    };
  }

  // Stops the component completely, potentially disengaging its power
  // electronics controller(s).
  //
  // Performs the following sequence actions for the following component
  // categories:
  //
  // * Inverter:
  //  * Brings component to the cold-standby state
  //  * opens DC relays
  //
  // * Battery: Checks if the power output is 0, then
  //  * opens DC relays
  //
  // * Relays:
  //  * opens relays
  //
  // * Precharge Modules:
  //  * opens the DC relays.
  //
  // If any of the checks mentioned above fails, then the method call returns an
  // error.
  //
  // If any of the above mentioned actions for a given component has already
  // been performed, then this method call effectively skips that action.
  //
  // If a feature required to perform an action is missing, then that action is
  // skipped.
  rpc StopComponent(StopComponentRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      get : "/v1/components/{id}/stop"
    };
  }

  // Acknowledges any recoverable error reported by the component, and brings it
  // back to the stopped or cold-standby state.
  rpc AckComponentError(AckComponentErrorRequest)
    returns (google.protobuf.Empty) {
    option (google.api.http) = {
      get : "/v1/components/{id}/errorAck"
    };
  }
}

// Metadata that describes a microgrid.
message GetMicrogridMetadataResponse {
  // The location of the microgrid, in geographical co-ordinates.
  frequenz.api.common.v1.microgrid.Microgrid  microgrid= 1;
}

// Request parameters for the RPC `ListComponents`.
// Contains filtering parameters for listing components.
message ListComponentsRequest {
  // Return components that have the specified IDs only.
  repeated uint64 component_ids = 1;

  // Return components that have the specified categories only.
  repeated frequenz.api.common.v1.microgrid.components.ComponentCategory
    categories = 2;
}

// A message containing a list of components.
// Used as the return type in the RPC `ListComponents`.
message ListComponentsResponse {
  repeated frequenz.api.common.v1.microgrid.components.Component components = 1;
}

// Request parameters for the RPC `ListSensors`.
// Contains filtering parameters for listing sensors.
message ListSensorRequest {
  // Return sensors that have the specified IDs only.
  repeated uint64 sensor_ids = 1;

  // Return sensors that have the specified categories only.
  repeated frequenz.api.common.v1.microgrid.sensors.SensorCategory
    categories = 2;
}

// Response message for the RPC `ListSensors`.
// A message containing a list of sensors.
message ListSensorsResponse {
  repeated frequenz.api.common.v1.microgrid.sensors.Sensor sensors = 1;
}

// Request parameters for the RPC `ListConnections`.
// Contains filtering parameters for listing connections.
message ListConnectionsRequest {
  // Only return connections that start from the specified component ID(s):
  // if empty, connections with any `start` will be returned
  repeated uint64 starts = 1;

  // Only return connections that end at the specified component ID(s):
  // if empty, connections with any `end` will be returned
  repeated uint64 ends = 2;
}

// Response message for the RPC `ListConnections`.
// Contains a list of connections.
message ListConnectionsResponse {
  // The list of connections.
  repeated frequenz.api.common.v1.microgrid.components.ComponentConnection
    connections = 1;
};

// Request parameters for the RPC `ReceiveComponentDataStream`.
message ReceiveComponentDataStreamRequest {
  // A message for specifying a filter to apply to the stream.
  message ComponentDataStreamFilter {
    // List of metrics to return. Only the specified metrics will be returned.
    //
    // !!! note
    //     At least one metric must be specified. If no metric is specified,
    //     then the stream will return an error.
    //
    // !!! note
    //     Components may not support all metrics. If a component does not
    //     support a given metric, then the returned data stream will not
    //     contain that metric.
    repeated frequenz.api.common.v1.metrics.Metric metrics = 1;
  }

  // The component ID to subscribe to.
  uint64 component_id = 1;

  // The filter to apply to the stream.
  //
  // This field is optional. If this is not provided, then the stream will
  // return all metrics for the given component. If this is provided, then the
  // stream will return only the metrics specified in the filter.
  ComponentDataStreamFilter filter = 2;
}

// A data sample from a component in the microgrid.
// Components belonging to all categories and types can be represented using
// this message.
message ReceiveComponentDataStreamResponse {
  frequenz.api.common.v1.microgrid.components.ComponentData data = 1;
}

// Request parameters for the RPC `ReceiveSensorDataStream`.
message ReceiveSensorDataStreamRequest {
  // A message for specifying a filter to apply to the stream.
  message SensorDataStreamFilter {
    // List of metrics to return. Only the specified metrics will be returned.
    //
    // !!! note
    //     At least one metric must be specified. If no metric is specified,
    //     then the stream will return an error.
    //
    // !!! note
    //     Sensors may not support all metrics. If a sensor does not support a
    //     given metric, then the returned data stream will not contain that
    //     metric.
    repeated frequenz.api.common.v1.metrics.Metric metrics = 1;
  }

  // The sensor ID to subscribe to.
  uint64 sensor_id = 1;

  // The filter to apply to the stream.
  //
  // This field is optional. If this is not provided, then the stream will
  // return all metrics for the given component. If this is provided, then the
  // stream will return only the metrics specified in the filter.
  SensorDataStreamFilter filter = 2;
}

// A data sample from a sensor in the microgrid.
message ReceiveSensorDataStreamResponse {
  // The sensor data.
  frequenz.api.common.v1.microgrid.sensors.SensorData data = 1;
}

// An enumerated list of metrics whose bounds can be set using the RPCs
// `AddComponentExclusionBounds` and `AddComponentInclusionBounds`.
enum ComponentBoundsTargetMetric {
  COMPONENT_BOUNDS_TARGET_METRIC_UNSPECIFIED = 0;
  COMPONENT_BOUNDS_TARGET_METRIC_POWER_ACTIVE = 1;
  COMPONENT_BOUNDS_TARGET_METRIC_CURRENT = 2;
  COMPONENT_BOUNDS_TARGET_METRIC_CURRENT_PHASE_1 = 3;
  COMPONENT_BOUNDS_TARGET_METRIC_CURRENT_PHASE_2 = 4;
  COMPONENT_BOUNDS_TARGET_METRIC_CURRENT_PHASE_3 = 5;
  COMPONENT_BOUNDS_TARGET_METRIC_POWER_REACTIVE = 6;
}

// Request parameters for the RPC `AddComponentExclusionBounds`.
message AddComponentExclusionBoundsRequest {
  // The ID of the target component.
  uint64 component_id = 1;

  // The target metric whose bounds have to be set.
  ComponentBoundsTargetMetric target_metric = 2;

  // The bounds for the target metric.
  frequenz.api.common.v1.metrics.Bounds bounds = 3;
}

// Response message for the RPC `AddComponentExclusionBounds`.
message AddComponentExclusionBoundsResponse {
  // The timestamp until which the given exclusion bounds will stay in effect.
  google.protobuf.Timestamp ts = 1;
}

// Request parameters for the RPC `AddComponentInclusionBounds`.
message AddComponentInclusionBoundsRequest {
  // The ID of the target component.
  uint64 component_id = 1;

  // The target metric whose bounds have to be set.
  ComponentBoundsTargetMetric target_metric = 2;

  // The bounds for the target metric.
  frequenz.api.common.v1.metrics.Bounds bounds = 3;
}

// Response message for the RPC `AddComponentInclusionBounds`.
message AddComponentInclusionBoundsResponse {
  // The timestamp until which the given inclusion bounds will stay in effect.
  google.protobuf.Timestamp ts = 1;
}

// Request parameters for the RPC `SetComponentPowerActive`.
message SetComponentPowerActiveRequest {
  // The ID of the component to set the output active power of.
  uint64 component_id = 1;

  // The output active power level, in watts.
  // -ve values are for discharging, and +ve values are for charging.
  float power = 2;
}

// Response message for the RPC `SetComponentPowerActive`.
message SetComponentPowerActiveResponse {
  // The timestamp until which the given power command will stay in effect.
  // After this timestamp, the component power will be set to 0, if the API
  // receives no further power commands. By default, this timestamp will be set
  // to the current time plus 60 seconds.
  google.protobuf.Timestamp valid_until = 1;
}

// Request parameters for the RPC `SetComponentPowerReactive`.
message SetComponentPowerReactiveRequest {
  // The ID of the component to set the output reactive power of.
  uint64 component_id = 1;

  // The output reactive power level, in VAr.
  // -ve values are for inductive (lagging) power , and +ve values are for
  //  capacitive (leading) power.
  float power = 2;
}

// Response message for the RPC `SetComponentPowerReactive`.
message SetComponentPowerReactiveResponse {
  // The timestamp until which the given power command will stay in effect.
  // After this timestamp, the component power will be set to 0, if the API
  // receives no further power commands. By default, this timestamp will be set
  // to the current time plus 60 seconds.
  google.protobuf.Timestamp valid_until = 1;
}

// Request parameters for the RPC `StartComponent`.
message StartComponentRequest {
  // The component ID to start.
  uint64 component_id = 1;
}

// Request parameters for the RPC `PutComponentInStandby`.
message PutComponentInStandbyRequest {
  // The component ID to set to standby.
  uint64 component_id = 1;
}

// Request parameters for the RPC `StopComponent`.
message StopComponentRequest {
  // The component ID to stop.
  uint64 component_id = 1;
}

// Request parameters for the RPC `AckComponentError`.
message AckComponentErrorRequest {
  // The component ID to acknowledge the error for.
  uint64 component_id = 1;
}
