{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Microgrid API","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Frequenz gRPC API for monitoring and control of microgrids.</p> <p>This repository provides the core gRPC and protobuf spec together with support for generating dedicated API packages for various languages.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Microgrid API","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You need to make sure you have the <code>git submodules</code> updated:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"CONTRIBUTING/#running-protolint","title":"Running protolint","text":"<p>To make sure some common mistakes are avoided and to ensure a consistent style it is recommended to run <code>protolint</code>. After you installed <code>protolint</code>, just run:</p> <pre><code>protolint lint proto\n</code></pre>"},{"location":"CONTRIBUTING/#python-setup","title":"Python setup","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>This will also generate the Python files from the <code>proto/</code> files and leave them in <code>py/</code>, so you can inspect them.</p> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#upgrading-dependencies","title":"Upgrading dependencies","text":"<p>If you want to update the dependency <code>frequenz-api-common</code>, then you need to:</p> <ol> <li>Update the submodule <code>frequenz-api-common</code></li> <li>Update the version of the <code>frequenz-api-common</code> package in <code>pyproject.toml</code></li> </ol> <p>The version of <code>frequenz-api-common</code> used in both places mentioned above should be the same.</p> <p>Here is an example of upgrading the <code>frequenz-api-common</code> dependency to version <code>v0.2.0</code>: <pre><code>ver=\"0.2.0\"\n\ncd submodules/frequenz-api-common\ngit remote update\ngit checkout v${ver}\ncd -\n\nsed s/\"frequenz-api-common == [0-9]\\.[0-9]\\.[0-9]\"/\"frequenz-api-common == ${ver}\"/g -i pyproject.toml\n</code></pre></p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Protobuf API Reference</li> <li>Python API Reference</li> <li>Contributing</li> </ul>"},{"location":"protobuf-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>microgrid<ul> <li>battery.proto</li> <li>common.proto</li> <li>ev_charger.proto</li> <li>grid.proto</li> <li>inverter.proto</li> <li>meter.proto</li> <li>microgrid.proto</li> <li>precharger.proto</li> <li>relay.proto</li> <li>sensor.proto</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"protobuf-reference/frequenz/api/microgrid/battery/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/battery.proto</p> <ul> <li>Battery</li> <li>Data</li> <li>Error</li> <li>Metadata</li> <li>Properties</li> <li> <p>State</p> </li> <li> <p>ComponentState</p> </li> <li>ErrorCode</li> <li>RelayState</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#frequenzapimicrogridbatteryproto","title":"frequenz/api/microgrid/battery.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#battery","title":"Battery","text":"<p>Battery/BMS details</p> Field Type Label Description properties Properties The component properties state State The battery state. errors Error repeated A list of errors encountered the component. An empty list implies no error. data Data A Battery data object. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#data","title":"Data","text":"<p>Battery data.</p> Field Type Label Description dc frequenz.api.common.v1.metrics.electrical.DC DC electricity metrics. soc frequenz.api.common.v1.metrics.MetricAggregation Battery's overall SoC. In percent (%). temperature frequenz.api.common.v1.metrics.MetricAggregation The aggregated values of all the temperature measurements of a battery. In degree Celsius (\u00b0C). humidity frequenz.api.common.v1.metrics.MetricAggregation The aggregated values of all the humidity measurements of a battery. In percent (%). <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#error","title":"Error","text":"<p>Error message.</p> Field Type Label Description code ErrorCode The error code. level frequenz.api.microgrid.common.ErrorLevel The error severity level. msg string The error message. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#metadata","title":"Metadata","text":"<p>The battery metadata.</p> Field Type Label Description type frequenz.api.common.v1.components.BatteryType The battery type. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#properties","title":"Properties","text":"<p>Battery properties.</p> Field Type Label Description firmware_ver string The firmware version of the battery. capacity float The capacity of the battery. In Watt-hour (Wh). <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#state","title":"State","text":"<p>State message.</p> Field Type Label Description component_state ComponentState The state of the overall component. relay_state RelayState The state of the DC relays. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#componentstate","title":"ComponentState","text":"Name Number Description COMPONENT_STATE_UNSPECIFIED 0 Default value. This value is used only when the state information is not available. COMPONENT_STATE_OFF 1 The battery is switched off. COMPONENT_STATE_IDLE 2 The battery is idle. COMPONENT_STATE_CHARGING 3 The battery is consuming electrical energy. COMPONENT_STATE_DISCHARGING 4 The battery is generating electrical energy. COMPONENT_STATE_ERROR 5 The battery is in a faulty state. COMPONENT_STATE_LOCKED 6 The battery is online, but currently unavailable, possibly due to a pre-scheduled maintenance, or waiting for a resource to be loaded. COMPONENT_STATE_SWITCHING_ON 7 The battery is starting up and needs some time to become fully operational. COMPONENT_STATE_SWITCHING_OFF 8 The battery is switching off and needs some time to fully shut down. COMPONENT_STATE_UNKNOWN 9 The state is provided by the device, but it can not be parsed as any of the above (known) states."},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#errorcode","title":"ErrorCode","text":"<p>Enumerated Battery/BMS error codes.</p> Name Number Description ERROR_CODE_UNSPECIFIED 0 Unspecified. ERROR_CODE_HIGH_CURRENT_CHARGE 1 Charge current is too high. ERROR_CODE_HIGH_CURRENT_DISCHARGE 2 Discharge current is too high. ERROR_CODE_HIGH_VOLTAGE 3 Voltage is too high. ERROR_CODE_LOW_VOLTAGE 4 Voltage is too low. ERROR_CODE_HIGH_TEMPERATURE 5 Temperature is too high. ERROR_CODE_LOW_TEMPERATURE 6 Temperature is too low. ERROR_CODE_HIGH_HUMIDITY 7 Humidity is too high. ERROR_CODE_EXCEEDED_SOP_CHARGE 8 Charge current has exceeded component bounds. ERROR_CODE_EXCEEDED_SOP_DISCHARGE 9 Discharge current has exceeded component bounds. ERROR_CODE_SYSTEM_IMBALANCE 10 The battery blocks are not balanced with respect to each other. ERROR_CODE_LOW_SOH 11 The State of health is low. ERROR_CODE_BLOCK_ERROR 12 One or more battery blocks have failed. ERROR_CODE_CONTROLLER_ERROR 13 The battery controller has failed. ERROR_CODE_RELAY_ERROR 14 The battery's DC relays have failed. ERROR_CODE_RELAY_CYCLE_LIMIT_REACHED 15 The battery's DC relays have been cycled for the maximum number of times mentioned in their lifetime specifications. ERROR_CODE_FUSE_ERROR 16 The battery's fuse has failed. ERROR_CODE_EXTERNAL_POWER_SWITCH_ERROR 17 The eternal power switch has failed. ERROR_CODE_PRECHARGE_ERROR 18 The precharge operation has failed. ERROR_CODE_SYSTEM_PLAUSIBILITY_ERROR 19 System plausibility checks have failed. ERROR_CODE_SYSTEM_UNDERVOLTAGE_SHUTDOWN 20 System shut down due to extremely low voltage. ERROR_CODE_CALIBRATION_NEEDED 21 The battery requires a calibration to reset its measurements. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#relaystate","title":"RelayState","text":"Name Number Description RELAY_STATE_UNSPECIFIED 0 Default value. RELAY_STATE_OPENED 1 The relays are open, and the DC power line to the inverter is disconnected. RELAY_STATE_PRECHARGING 2 The relays are closing, and the DC power line to the inverter is being connected. RELAY_STATE_CLOSED 3 The relays are closed, and the DC power line to the inverter is connected. RELAY_STATE_ERROR 4 The relays are in an error state. RELAY_STATE_LOCKED 5 The relays are locked, and should be available to accept commands shortly."},{"location":"protobuf-reference/frequenz/api/microgrid/battery/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/microgrid/common/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/common/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/common.proto</p> <ul> <li>ErrorLevel</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/common/#frequenzapimicrogridcommonproto","title":"frequenz/api/microgrid/common.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/common/#errorlevel","title":"ErrorLevel","text":"<p>Error levels definitions.</p> Name Number Description ERROR_LEVEL_UNSPECIFIED 0 Unspecified component error. ERROR_LEVEL_WARN 1 Action must be taken to prevent a severe error from occurring in the future. ERROR_LEVEL_CRITICAL 2 A severe error that causes the component to fail. Immediate action must be taken."},{"location":"protobuf-reference/frequenz/api/microgrid/common/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/ev_charger.proto</p> <ul> <li>Data</li> <li>Error</li> <li>EvCharger</li> <li>Metadata</li> <li>Properties</li> <li> <p>State</p> </li> <li> <p>CableState</p> </li> <li>ComponentState</li> <li>ErrorCode</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#frequenzapimicrogridev_chargerproto","title":"frequenz/api/microgrid/ev_charger.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#data","title":"Data","text":"<p>EV charger data.</p> Field Type Label Description dc frequenz.api.common.v1.metrics.electrical.DC DC metrics of the EV charging station. Contains data only if DC charging is supported by the EV charging station. (in which case, the type of the EV charging station is TYPE_DC or TYPE_HYBRID) ac frequenz.api.common.v1.metrics.electrical.AC AC metrics of the EV charging station. Contains data only if AC charging is supported by the EV charging station. (in which case, the type of the EV charging station is TYPE_AC or TYPE_HYBRID) temperature frequenz.api.common.v1.metrics.Metric The overall temperature of the EV charger. In degree Celsius (\u00b0C). <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#error","title":"Error","text":"<p>Error message.</p> Field Type Label Description code ErrorCode The error code. level frequenz.api.microgrid.common.ErrorLevel The error severity level. msg string The error message. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#evcharger","title":"EvCharger","text":"<p>EvCharger details</p> Field Type Label Description properties Properties The component properties state State The EV charging station's state. errors Error repeated A list of errors encountered the component. An empty list implies no error. data Data An EV charger data object. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#metadata","title":"Metadata","text":"<p>The EV charger metadata.</p> Field Type Label Description type frequenz.api.common.v1.components.EvChargerType The EV charger type. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#properties","title":"Properties","text":"<p>EV charger properties.</p> Field Type Label Description firmware_ver string The firmware version of the component. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#state","title":"State","text":"<p>State message.</p> Field Type Label Description component_state ComponentState The state of the overall component. cable_state CableState The state of the charging cable. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#cablestate","title":"CableState","text":"<p>The possible states of the cable connecting an EV charging station and an EV.</p> Name Number Description CABLE_STATE_UNSPECIFIED 0 Default state. CABLE_STATE_UNPLUGGED 1 No cable is connected to the EV charging station. CABLE_STATE_CHARGING_STATION_PLUGGED 2 A cable is connected to the EV charging station, but is not locked with it. CABLE_STATE_CHARGING_STATION_LOCKED 3 A cable is connected to and locked with the EV charging station. CABLE_STATE_EV_PLUGGED 4 A cable is connected to and locked with the EV charging station. The same cable is connected to the EV, but is not locked with it. CABLE_STATE_EV_LOCKED 5 A cable is connected to and locked with the EV charging station. The same cable is connected to and locked with the EV. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#componentstate","title":"ComponentState","text":"<p>The possible states of an EV charging station.</p> Name Number Description COMPONENT_STATE_UNSPECIFIED 0 Default state. This value is used only when the state information is not available. COMPONENT_STATE_STARTING 1 The EV charging station is starting up. COMPONENT_STATE_NOT_READY 2 The EV charging station is unplugged or RFID is not working. COMPONENT_STATE_READY 3 The EV charging station is ready and waiting for a charging request COMPONENT_STATE_CHARGING 4 The EV charging station is charging an EV. COMPONENT_STATE_DISCHARGING 5 The EV charging station is discharging from an EV into the local microgrid. COMPONENT_STATE_ERROR 6 The EV charging station is in an error state. COMPONENT_STATE_AUTHORIZATION_REJECTED 7 The EV charging station rejected the last authorization. COMPONENT_STATE_INTERRUPTED 8 The EV charging process hes been temporarily interrupted. COMPONENT_STATE_UNKNOWN 9 The state is provided by the device, but it can not be parsed as any of the above (known) states. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#errorcode","title":"ErrorCode","text":"<p>Enumerated EV charger error codes.</p> Name Number Description ERROR_CODE_UNSPECIFIED 0 Unspecified. ERROR_CODE_SWITCH_ON_FAULT 1 Something is preventing the DC contactor from being switched on. ERROR_CODE_UNDERVOLTAGE 2 AC supply voltage is lower than expected. ERROR_CODE_OVERVOLTAGE 3 AC supply voltage is higher than expected. ERROR_CODE_OVERCURRENT 4 DC charging voltage is higher than expected. ERROR_CODE_OVERTEMPERATURE 5 Temperature in the charging station is higher than expected. ERROR_CODE_UNEXPECTED_PILOT_FAILURE 6 EV has sent an unexpected pilot signal. ERROR_CODE_FAULT_CURRENT 7 A fault current has been detected. ERROR_CODE_SHORT_CIRCUIT 8 A short circuit has been detected. ERROR_CODE_CONFIG_ERROR 9 The system is incorrectly configured. ERROR_CODE_ILLEGAL_COMPONENT_STATE_REQUESTED 10 The system received a request to move to an illegal state. ERROR_CODE_HARDWARE_INACCESSIBLE 11 The system cannot access the internal hardware. ERROR_CODE_INTERNAL 12 The system has detected an unspecified internal error. ERROR_CODE_CABLE_LOST 13 The charging cable was unplugged unexpectedly. ERROR_CODE_CABLE_LOCK_FAILED 14 The charging cable could not be locked. ERROR_CODE_CABLE_INVALID 15 The charging cable could not be locked. ERROR_CODE_PLUG_UNKNOWN 16 The charging cable has an unrecognised plug. ERROR_CODE_CONSUMER_NON_STANDARD 17 The connected consumer is not a standard-compliant EV."},{"location":"protobuf-reference/frequenz/api/microgrid/ev_charger/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/microgrid/grid/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/grid/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/grid.proto</p> <ul> <li>Metadata</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/grid/#frequenzapimicrogridgridproto","title":"frequenz/api/microgrid/grid.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/grid/#metadata","title":"Metadata","text":"<p>The grid connection point metadata.</p> Field Type Label Description rated_fuse_current uint32 This refers to the maximum amount of electrical current, in amperes, that a fuse at the grid connection point is designed to safely carry under normal operating conditions. <p>This limit applies to currents both flowing in or out of each of the 3 phases individually.</p> <p>In other words, a current i A at one of the phases of the grid connection point must comply with the following constraint: <code>-rated_fuse_current &amp;lt;= i &amp;lt;= rated_fuse_current</code> |</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/grid/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/inverter.proto</p> <ul> <li>Data</li> <li>Error</li> <li>Inverter</li> <li>Metadata</li> <li>Properties</li> <li> <p>State</p> </li> <li> <p>ComponentState</p> </li> <li>ErrorCode</li> <li>Type</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#frequenzapimicrogridinverterproto","title":"frequenz/api/microgrid/inverter.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#data","title":"Data","text":"<p>Inverter data.</p> Field Type Label Description dc_battery frequenz.api.common.v1.metrics.electrical.DC DC metrics for the inverter-battery linkage. This is applicable to <code>BATTERY</code> and <code>HYBRID</code> inverters only. dc_solar frequenz.api.common.v1.metrics.electrical.DC DC metrics for the inverter-PV linkage. This is applicable to <code>SOLAR</code> and <code>HYBRID</code> inverters only. ac frequenz.api.common.v1.metrics.electrical.AC AC metrics of the inverter. temperature frequenz.api.common.v1.metrics.Metric The verall temperature of the inverter. In degree Celsius (\u00b0C). <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#error","title":"Error","text":"<p>Error message.</p> Field Type Label Description code ErrorCode The error code. level frequenz.api.microgrid.common.ErrorLevel The error severity level. msg string The error message. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#inverter","title":"Inverter","text":"<p>Inverter message definition.</p> Field Type Label Description properties Properties The component properties state State The inverter's state. errors Error repeated A list of errors encountered the component. An empty list implies no error. data Data An inverter data object. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#metadata","title":"Metadata","text":"<p>The inverter metadata.</p> Field Type Label Description type frequenz.api.common.v1.components.InverterType The inverter type. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#properties","title":"Properties","text":"<p>Inverter properties.</p> Field Type Label Description firmware_ver string The firmware version of the component. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#state","title":"State","text":"<p>State message.</p> Field Type Label Description component_state ComponentState The state of the overall component. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#componentstate","title":"ComponentState","text":"<p>Enumerated inverter states.</p> Name Number Description COMPONENT_STATE_UNSPECIFIED 0 Default value. COMPONENT_STATE_OFF 1 Inverter is switched off. COMPONENT_STATE_SWITCHING_ON 2 The inverter is starting up and needs some time to become fully operational. COMPONENT_STATE_SWITCHING_OFF 3 The inverter is switching off and needs some time to fully shut down. COMPONENT_STATE_STANDBY 4 The inverter is in a standby state, and is disconnected from the grid. When connected to the grid, it run a few tests, and move to the <code>IDLE</code> state. COMPONENT_STATE_IDLE 5 The inverter is idle. COMPONENT_STATE_CHARGING 10 The inverter is consuming electrical energy to charge batteries. Applicable to <code>BATTERY</code> and <code>HYBRID</code> inverters only. COMPONENT_STATE_DISCHARGING 11 The inverter is generating electrical energy. COMPONENT_STATE_ERROR 14 The inverter is in a faulty state. COMPONENT_STATE_UNAVAILABLE 15 The inverter is online, but currently unavailable, possibly due to a pre-scheduled maintenance. COMPONENT_STATE_UNKNOWN 16 The state is provided by the device, but it can not be parsed as any of the above (known) states. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#errorcode","title":"ErrorCode","text":"<p>Enumerated inverter error codes.</p> Name Number Description ERROR_CODE_UNSPECIFIED 0 Unspecified. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#type","title":"Type","text":"<p>Enumerated inverter types.</p> Name Number Description TYPE_UNSPECIFIED 0 TYPE_BATTERY 1 TYPE_SOLAR 2 TYPE_HYBRID 3"},{"location":"protobuf-reference/frequenz/api/microgrid/inverter/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/meter.proto</p> <ul> <li>Data</li> <li>Error</li> <li>Metadata</li> <li>Meter</li> <li>Properties</li> <li> <p>State</p> </li> <li> <p>ComponentState</p> </li> <li>ErrorCode</li> <li>Type</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#frequenzapimicrogridmeterproto","title":"frequenz/api/microgrid/meter.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#data","title":"Data","text":"<p>Meter data.</p> Field Type Label Description ac frequenz.api.common.v1.metrics.electrical.AC AC metrics of the inverter. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#error","title":"Error","text":"<p>Error message.</p> Field Type Label Description code ErrorCode The error code. level frequenz.api.microgrid.common.ErrorLevel The error severity level. msg string The error message. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#metadata","title":"Metadata","text":"<p>The meter metadata.</p> Field Type Label Description type Type The meter type. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#meter","title":"Meter","text":"<p>Meter details</p> Field Type Label Description properties Properties The component properties state State The meter's state. errors Error repeated A list of errors encountered the component. An empty list implies no error. data Data A meter data object. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#properties","title":"Properties","text":"<p>Meter properties.</p> Field Type Label Description firmware_ver string The firmware version of the component. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#state","title":"State","text":"<p>State message.</p> Field Type Label Description component_state ComponentState The state of the overall component. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#componentstate","title":"ComponentState","text":"<p>Enumerated meter states.</p> Name Number Description COMPONENT_STATE_UNSPECIFIED 0 Unspecified state. COMPONENT_STATE_OK 1 The meter is behaving as expected. COMPONENT_STATE_ERROR 2 The meter is in an error state. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#errorcode","title":"ErrorCode","text":"<p>Enumerated meter error codes.</p> Name Number Description ERROR_CODE_UNSPECIFIED 0 Unspecified. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#type","title":"Type","text":"<p>Enumerated meter types.</p> Name Number Description TYPE_UNSPECIFIED 0 TYPE_PRODUCTION 1 AC production power meter / inverter production AC power (fallback) TYPE_CONSUMPTION 2 Consumption meter TYPE_FEED_IN 3 Exported to grid meter TYPE_PURCHASED 4 Imported power from grid meter"},{"location":"protobuf-reference/frequenz/api/microgrid/meter/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/microgrid.proto</p> <ul> <li>Component</li> <li>ComponentData</li> <li>ComponentFilter</li> <li>ComponentIdParam</li> <li>ComponentList</li> <li>Connection</li> <li>ConnectionFilter</li> <li>ConnectionList</li> <li>MicrogridMetadata</li> <li>PowerLevelParam</li> <li>SetBoundsParam</li> <li>SetPowerActiveParam</li> <li> <p>SetPowerReactiveParam</p> </li> <li> <p>SetBoundsParam.TargetMetric</p> </li> <li> <p>Microgrid</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#frequenzapimicrogridmicrogridproto","title":"frequenz/api/microgrid/microgrid.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#component","title":"Component","text":"<p>A generic message for components. It is used to represent any category of component, with its static parameters.</p> Field Type Label Description id uint64 A unique identifier for the component. name string An optional name for the component. category frequenz.api.common.v1.components.ComponentCategory The category of the component. manufacturer string The component manufacturer. model_name string The model name of the component. grid grid.Metadata battery battery.Metadata inverter inverter.Metadata meter meter.Metadata ev_charger ev_charger.Metadata sensor sensor.Metadata <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#componentdata","title":"ComponentData","text":"<p>A generic container for data that can originate from any component type.</p> Field Type Label Description ts google.protobuf.Timestamp The timestamp of when the data was measured. id uint64 The component ID. meter meter.Meter inverter inverter.Inverter battery battery.Battery ev_charger ev_charger.EvCharger sensor sensor.Sensor relay relay.Relay precharger precharger.Precharger <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#componentfilter","title":"ComponentFilter","text":"<p>Parameters for filtering the components.</p> Field Type Label Description ids uint64 repeated Return components that have the specified IDs only. categories frequenz.api.common.v1.components.ComponentCategory repeated Return components that have the specified categories only. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#componentidparam","title":"ComponentIdParam","text":"<p>Encapsulation of a component ID, intended to be used as a parameter for rpc methods.</p> Field Type Label Description id uint64 <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#componentlist","title":"ComponentList","text":"<p>A message containing a list of components, used as a return typ in certain RPC methods.</p> Field Type Label Description components Component repeated <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#connection","title":"Connection","text":"<p>Describes a single connection between components of the microgrid, with direction away from the grid endpoint, meaning it is aligned with positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p> Field Type Label Description start uint64 <code>id</code> of the component the connection starts from end uint64 <code>id</code> of the component the connection points to <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#connectionfilter","title":"ConnectionFilter","text":"<p>Parameters for filtering the component connections</p> Field Type Label Description starts uint64 repeated Only return connections that start from the specified component ID(s): if empty, connections with any <code>start</code> will be returned ends uint64 repeated Only return connections that end at the specified component ID(s): if empty, connections with any <code>end</code> will be returned <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#connectionlist","title":"ConnectionList","text":"<p>List of connections between components</p> Field Type Label Description connections Connection repeated <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#microgridmetadata","title":"MicrogridMetadata","text":"<p>Metadata that describes a microgrid.</p> Field Type Label Description microgrid_id uint64 The microgrid ID. This is a natural number that uniquely identifies a given microgrid. location frequenz.api.common.v1.location.Location The location of the microgrid, in geographical co-ordinates. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#powerlevelparam","title":"PowerLevelParam","text":"<p>Parameters for setting the charge/discharge power of an appropriate component.</p> Field Type Label Description component_id uint64 The ID of the component to set the output power of. power_w uint64 The output power level, in watts. This is always a +ve integer. The sign of the power level is controlled by the implementations of the <code>Charge</code> and <code>Discharge</code> RPC methods. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#setboundsparam","title":"SetBoundsParam","text":"<p>Parameters for setting bounds of a given metric of a given component.</p> Field Type Label Description component_id uint64 The ID of the target component. target_metric SetBoundsParam.TargetMetric The target metric whose bounds have to be set. bounds frequenz.api.common.v1.metrics.Bounds The bounds for the target metric. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#setpoweractiveparam","title":"SetPowerActiveParam","text":"<p>Parameters for setting the active power of an appropriate component using the <code>SetPowerActive</code> RPC.</p> Field Type Label Description component_id uint64 The ID of the component to set the output active power of. power float The output active power level, in watts. -ve values are for discharging, and +ve values are for charging. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#setpowerreactiveparam","title":"SetPowerReactiveParam","text":"<p>Parameters for setting the reactive power of an appropriate component using the <code>SetPowerReactive</code> RPC.</p> Field Type Label Description component_id uint64 The ID of the component to set the output reactive power of. power float The output reactive power level, in VAr. -ve values are for inductive (lagging) power , and +ve values are for capacitive (leading) power. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#setboundsparamtargetmetric","title":"SetBoundsParam.TargetMetric","text":"<p>An enumerated list of metrics whose bounds can be set.</p> Name Number Description TARGET_METRIC_UNSPECIFIED 0 TARGET_METRIC_POWER_ACTIVE 1 TARGET_METRIC_CURRENT 2 TARGET_METRIC_CURRENT_PHASE_1 3 TARGET_METRIC_CURRENT_PHASE_2 4 TARGET_METRIC_CURRENT_PHASE_3 5 TARGET_METRIC_POWER_REACTIVE 6 <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#microgrid","title":"Microgrid","text":"Method Name Request Type Response Type Description GetMicrogridMetadata .google.protobuf.Empty MicrogridMetadata Returns the microgrid metadata / The metadata consists of information that describes the overall / microgrid, as opposed to its components, / e.g., the microgrid ID, location. ListComponents ComponentFilter ComponentList List components in the local microgrid, optionally filtered by a given list of component IDs and component categories. <p>If provided, the filters for component IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [ <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code>, <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code> OR <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>.</p> <p>If a filter list is empty, then that filter is not applied. | | ListConnections | ConnectionFilter | ConnectionList | Returns a list of the connections between components as <code>(start, end)</code> pairs of connection IDs, where the direction of individual connections is always away from the grid endpoint, i.e. aligned with the direction of positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p> <p>The request may be filtered by <code>start</code>/<code>end</code> component(s) of individual connections. If provided, the <code>start</code> and <code>end</code> filters have an <code>AND</code> relationship between each other, meaning that they are applied serially, but an <code>OR</code> relationship with other elements in the same list. For example, if <code>start</code> = <code>[1, 2, 3]</code>, and <code>end</code> = <code>[4, 5, 6]</code>, then the result should have all the connections where * each <code>start</code> component ID is either <code>1</code>, <code>2</code>, OR <code>3</code>, AND * each <code>end</code> component ID is either <code>4</code>, <code>5</code>, OR <code>6</code>. | | SubscribeComponentData | ComponentIdParam | ComponentData stream | Returns a stream containing data from a component with a given ID. | | AddComponentExclusionBounds | SetBoundsParam | .google.protobuf.Timestamp | Adds exclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given exclusion bounds will stay in effect.</p> <p>Exclusion bounds refer to the range of values that are disallowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraints <code>value &amp;lt;= lower</code> OR <code>upper &amp;lt;= value</code>.</p> <p>Exclusion bounds are a useful tool for enhancing the performance of a system. They can be used to restrict the acceptance of commands that fall below a certain threshold, which can help ensure the smooth functioning of the system. E.g., exclusion bounds can be set to limit the minimum charging power to a sufficiently high level, preventing a peak-shaver client from sending charge powers that are too low when a DC heater client is executing a charge pulse. This can significantly improve the overall performance of the DC heating mechanism.</p> <p>If multiple exclusion bounds have been provided bor a metric, then the aggregated lower and upper exclusion bounds are calculated as follows: lower: the minimum of all lower exclusion bounds upper: the maximum of all upper exclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_inclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <code>inclusion.lower inclusion.upper &amp;lt;-------|============|------------------|============|---------&amp;gt; exclusion.lower exclusion.upper</code> ---- values here are disallowed and wil be rejected ==== vales here are allowed and will be accepted | | AddComponentInclusionBounds | SetBoundsParam | .google.protobuf.Timestamp | Adds inclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given inclusion bounds will stay in effect.</p> <p>Inclusion bounds refer to the range of values that are allowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraint <code>lower &amp;lt;= value &amp;lt;= upper</code>.</p> <p>If multiple inclusion bounds have been provided bor a metric, then the aggregated lower and upper inclusion bounds are calculated as follows: lower: the maximum of all lower inclusion bounds upper: the minimum of all upper inclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_exclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <code>inclusion.lower inclusion.upper &amp;lt;-------|============|------------------|============|---------&amp;gt; exclusion.lower exclusion.upper</code> ---- values here are disallowed and wil be rejected ==== vales here are allowed and will be accepted | | SetComponentPowerActive | SetPowerActiveParam | .google.protobuf.Empty | Sets the active power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 W. E.g., an inverter may have a resolution of 88 W. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Sends the discharge command to the inverter, making it deliver AC power. | | SetComponentPowerReactive | SetPowerReactiveParam | .google.protobuf.Empty | Sets the reactive power output of a component with a given ID, provided the component supports it.</li> </ul> <p>Note that the target component may have a resolution of more than 1 VAr. E.g., an inverter may have a resolution of 88 VAr. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution. | | StartComponent | ComponentIdParam | .google.protobuf.Empty | Starts the component, and brings it into a state where it is immediately operational.</p> <p>Performs the following sequence of actions for the following component categories:</p> <ul> <li> <p>Inverter: * closes DC relays, if the feature is available * closes AC relays * sets power output to 0</p> </li> <li> <p>Battery: Checks if DC relays are open, then * closes DC relays</p> </li> <li> <p>Relays: * closes relays</p> </li> <li> <p>Precharge Modules: * starts the precharge process, and eventually closes the DC relays.</p> </li> </ul> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped. | | HotStandbyComponent | ComponentIdParam | .google.protobuf.Empty | Sets the given component into a hot-standby state, from which it can return into an operational state within at most 5 seconds.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then * sets power to 0</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action. | | ColdStandbyComponent | ComponentIdParam | .google.protobuf.Empty | Sets the given component into a cold-standby state, from which it can return into an operational state within at most 2 minutes.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then * sets power to 0, and * opens AC relays</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call efffectively skips that action. | | StopComponent | ComponentIdParam | .google.protobuf.Empty | Stops the component completely, potentially disengaging its power electronics controller(s).</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li> <p>Inverter: * Brings component to the cold-standby state * opens DC relays</p> </li> <li> <p>Battery: Checks if the power output is 0, then * opens DC relays</p> </li> <li> <p>Relays: * opens relays</p> </li> <li> <p>Precharge Modules: * opens the DC relays.</p> </li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped. | | AckComponentError | ComponentIdParam | .google.protobuf.Empty | Acknowledges any recoverable error reported by the component, and brings it back to the stopped or cold-standby state. |</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/microgrid/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/microgrid/precharger/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/precharger/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/precharger.proto</p> <ul> <li>Error</li> <li>Precharger</li> <li> <p>State</p> </li> <li> <p>ComponentState</p> </li> <li>ErrorCode</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/precharger/#frequenzapimicrogridprechargerproto","title":"frequenz/api/microgrid/precharger.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/precharger/#error","title":"Error","text":"<p>Error message.</p> Field Type Label Description code ErrorCode The error code. level frequenz.api.microgrid.common.ErrorLevel The error severity level. msg string The error message. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/precharger/#precharger","title":"Precharger","text":"<p>Precharger details.</p> Field Type Label Description state State The component's state. errors Error repeated A list of errors encountered the component. An empty list implies no error. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/precharger/#state","title":"State","text":"<p>State message.</p> Field Type Label Description component_state ComponentState The state of the overall component. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/precharger/#componentstate","title":"ComponentState","text":"<p>Enumerated meter states.</p> Name Number Description COMPONENT_STATE_UNSPECIFIED 0 Unspecified state. COMPONENT_STATE_OFF 1 The precharge and the relsays are opened. COMPONENT_STATE_PRECHARGING 2 Precharging is in progress. COMPONENT_STATE_ON 3 The relays are on/closed, and the precharge circuit is open. COMPONENT_STATE_ERROR 4 The precharge module is in an error state. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/precharger/#errorcode","title":"ErrorCode","text":"<p>Enumerated error codes.</p> Name Number Description ERROR_CODE_UNSPECIFIED 0 Unspecified."},{"location":"protobuf-reference/frequenz/api/microgrid/precharger/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/microgrid/relay/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/relay/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/relay.proto</p> <ul> <li>Error</li> <li>Relay</li> <li> <p>State</p> </li> <li> <p>ComponentState</p> </li> <li>ErrorCode</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/relay/#frequenzapimicrogridrelayproto","title":"frequenz/api/microgrid/relay.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/relay/#error","title":"Error","text":"<p>Error message.</p> Field Type Label Description code ErrorCode The error code. level frequenz.api.microgrid.common.ErrorLevel The error severity level. msg string The error message. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/relay/#relay","title":"Relay","text":"<p>Relay details.</p> Field Type Label Description state State The component's state. errors Error repeated A list of errors encountered the component. An empty list implies no error. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/relay/#state","title":"State","text":"<p>State message.</p> Field Type Label Description component_state ComponentState The state of the overall component. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/relay/#componentstate","title":"ComponentState","text":"<p>Enumerated relay states.</p> Name Number Description COMPONENT_STATE_UNSPECIFIED 0 Unspecified state. COMPONENT_STATE_OFF 1 The relays are off/open. COMPONENT_STATE_ON 2 The relays are on/closed. COMPONENT_STATE_ERROR 4 The relay is in an error state. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/relay/#errorcode","title":"ErrorCode","text":"<p>Enumerated error codes.</p> Name Number Description ERROR_CODE_UNSPECIFIED 0 Unspecified."},{"location":"protobuf-reference/frequenz/api/microgrid/relay/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/sensor.proto</p> <ul> <li>Data</li> <li>Error</li> <li>Metadata</li> <li>Properties</li> <li>Sensor</li> <li>SensorData</li> <li> <p>State</p> </li> <li> <p>ComponentState</p> </li> <li>ErrorCode</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#frequenzapimicrogridsensorproto","title":"frequenz/api/microgrid/sensor.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#data","title":"Data","text":"<p>Sensor data.</p> Field Type Label Description sensor_data SensorData repeated An array of sensor data. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#error","title":"Error","text":"<p>Error message.</p> Field Type Label Description code ErrorCode The error code. level frequenz.api.microgrid.common.ErrorLevel The error severity level. msg string The error message. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#metadata","title":"Metadata","text":"<p>The sensor metadata.</p> Field Type Label Description type frequenz.api.common.v1.sensors.SensorCategory The sensor type. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#properties","title":"Properties","text":"<p>Sensor properties.</p> Field Type Label Description firmware_ver string The firmware version of the component. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#sensor","title":"Sensor","text":"<p>Sensor details</p> Field Type Label Description properties Properties The component properties state State The sensor's state. errors Error repeated A list of errors encountered the component. An empty list implies no error. data Data Sensor data object. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#sensordata","title":"SensorData","text":"<p>A value of a single metric.</p> Field Type Label Description value float The metric value. sensor_metric frequenz.api.common.v1.sensors.SensorMetric The metric name. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#state","title":"State","text":"<p>State message.</p> Field Type Label Description component_state ComponentState The state of the overall component. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#componentstate","title":"ComponentState","text":"<p>Enumerated sensor states.</p> Name Number Description COMPONENT_STATE_UNSPECIFIED 0 Unspecified state. COMPONENT_STATE_OK 1 The sensor is behaving as expected. COMPONENT_STATE_ERROR 2 The sensor is in an error state. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#errorcode","title":"ErrorCode","text":"<p>Enumerated sensor error codes.</p> Name Number Description ERROR_CODE_UNSPECIFIED 0 Unspecified."},{"location":"protobuf-reference/frequenz/api/microgrid/sensor/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"python-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>microgrid<ul> <li>battery_pb2</li> <li>battery_pb2_grpc</li> <li>common_pb2</li> <li>common_pb2_grpc</li> <li>ev_charger_pb2</li> <li>ev_charger_pb2_grpc</li> <li>grid_pb2</li> <li>grid_pb2_grpc</li> <li>inverter_pb2</li> <li>inverter_pb2_grpc</li> <li>meter_pb2</li> <li>meter_pb2_grpc</li> <li>microgrid_pb2</li> <li>microgrid_pb2_grpc</li> <li>precharger_pb2</li> <li>precharger_pb2_grpc</li> <li>relay_pb2</li> <li>relay_pb2_grpc</li> <li>sensor_pb2</li> <li>sensor_pb2_grpc</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"python-reference/frequenz/api/microgrid/","title":"microgrid","text":""},{"location":"python-reference/frequenz/api/microgrid/#frequenz.api.microgrid","title":"<code>frequenz.api.microgrid</code>","text":"<p>Frequenz gRPC API for monitoring and control of microgrids.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/","title":"battery_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2","title":"<code>frequenz.api.microgrid.battery_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_CHARGING","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_CHARGING: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery is consuming electrical energy.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_DISCHARGING","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_DISCHARGING: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery is generating electrical energy.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_ERROR","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_ERROR: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery is in a faulty state.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_IDLE","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_IDLE: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery is idle.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_LOCKED","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_LOCKED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery is online, but currently unavailable, possibly due to a pre-scheduled maintenance, or waiting for a resource to be loaded.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_OFF","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_OFF: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery is switched off.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_SWITCHING_OFF","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_SWITCHING_OFF: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery is switching off and needs some time to fully shut down.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_SWITCHING_ON","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_SWITCHING_ON: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery is starting up and needs some time to become fully operational.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_UNKNOWN","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_UNKNOWN: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The state is provided by the device, but it can not be parsed as any of the above (known) states.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.battery_pb2.COMPONENT_STATE_UNSPECIFIED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>Default value. This value is used only when the state information is not available.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_BLOCK_ERROR","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_BLOCK_ERROR: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>One or more battery blocks have failed.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_CALIBRATION_NEEDED","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_CALIBRATION_NEEDED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery requires a calibration to reset its measurements.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_CONTROLLER_ERROR","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_CONTROLLER_ERROR: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery controller has failed.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_EXCEEDED_SOP_CHARGE","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_EXCEEDED_SOP_CHARGE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Charge current has exceeded component bounds.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_EXCEEDED_SOP_DISCHARGE","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_EXCEEDED_SOP_DISCHARGE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Discharge current has exceeded component bounds.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_EXTERNAL_POWER_SWITCH_ERROR","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_EXTERNAL_POWER_SWITCH_ERROR: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The eternal power switch has failed.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_FUSE_ERROR","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_FUSE_ERROR: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery's fuse has failed.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_CURRENT_CHARGE","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_CURRENT_CHARGE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Charge current is too high.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_CURRENT_DISCHARGE","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_CURRENT_DISCHARGE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Discharge current is too high.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_HUMIDITY","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_HUMIDITY: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Humidity is too high.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_TEMPERATURE","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_TEMPERATURE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Temperature is too high.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_VOLTAGE","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_HIGH_VOLTAGE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Voltage is too high.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_LOW_SOH","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_LOW_SOH: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The State of health is low.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_LOW_TEMPERATURE","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_LOW_TEMPERATURE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Temperature is too low.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_LOW_VOLTAGE","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_LOW_VOLTAGE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Voltage is too low.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_PRECHARGE_ERROR","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_PRECHARGE_ERROR: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The precharge operation has failed.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_RELAY_CYCLE_LIMIT_REACHED","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_RELAY_CYCLE_LIMIT_REACHED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery's DC relays have been cycled for the maximum number of times mentioned in their lifetime specifications.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_RELAY_ERROR","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_RELAY_ERROR: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery's DC relays have failed.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_SYSTEM_IMBALANCE","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_SYSTEM_IMBALANCE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The battery blocks are not balanced with respect to each other.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_SYSTEM_PLAUSIBILITY_ERROR","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_SYSTEM_PLAUSIBILITY_ERROR: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>System plausibility checks have failed.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_SYSTEM_UNDERVOLTAGE_SHUTDOWN","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_SYSTEM_UNDERVOLTAGE_SHUTDOWN: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>System shut down due to extremely low voltage.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ERROR_CODE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.battery_pb2.ERROR_CODE_UNSPECIFIED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.RELAY_STATE_CLOSED","title":"<code>frequenz.api.microgrid.battery_pb2.RELAY_STATE_CLOSED: RelayState.ValueType</code>  <code>module-attribute</code>","text":"<p>The relays are closed, and the DC power line to the inverter is connected.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.RELAY_STATE_ERROR","title":"<code>frequenz.api.microgrid.battery_pb2.RELAY_STATE_ERROR: RelayState.ValueType</code>  <code>module-attribute</code>","text":"<p>The relays are in an error state.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.RELAY_STATE_LOCKED","title":"<code>frequenz.api.microgrid.battery_pb2.RELAY_STATE_LOCKED: RelayState.ValueType</code>  <code>module-attribute</code>","text":"<p>The relays are locked, and should be available to accept commands shortly.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.RELAY_STATE_OPENED","title":"<code>frequenz.api.microgrid.battery_pb2.RELAY_STATE_OPENED: RelayState.ValueType</code>  <code>module-attribute</code>","text":"<p>The relays are open, and the DC power line to the inverter is disconnected.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.RELAY_STATE_PRECHARGING","title":"<code>frequenz.api.microgrid.battery_pb2.RELAY_STATE_PRECHARGING: RelayState.ValueType</code>  <code>module-attribute</code>","text":"<p>The relays are closing, and the DC power line to the inverter is being connected.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.RELAY_STATE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.battery_pb2.RELAY_STATE_UNSPECIFIED: RelayState.ValueType</code>  <code>module-attribute</code>","text":"<p>Default value.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Battery","title":"<code>frequenz.api.microgrid.battery_pb2.Battery</code>","text":"<p>             Bases: <code>Message</code></p> <p>Battery/BMS details</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Battery-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Battery.data","title":"<code>data: global___Data</code>  <code>property</code>","text":"<p>A Battery data object.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Battery.errors","title":"<code>errors: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]</code>  <code>property</code>","text":"<p>A list of errors encountered the component. An empty list implies no error.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Battery.properties","title":"<code>properties: global___Properties</code>  <code>property</code>","text":"<p>The component properties</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Battery.state","title":"<code>state: global___State</code>  <code>property</code>","text":"<p>The battery state.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Data","title":"<code>frequenz.api.microgrid.battery_pb2.Data</code>","text":"<p>             Bases: <code>Message</code></p> <p>Battery data.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Data-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Data.dc","title":"<code>dc: frequenz.api.common.v1.metrics.electrical_pb2.DC</code>  <code>property</code>","text":"<p>DC electricity metrics.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Data.humidity","title":"<code>humidity: frequenz.api.common.v1.metrics_pb2.MetricAggregation</code>  <code>property</code>","text":"<p>The aggregated values of all the humidity measurements of a battery. In percent (%).</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Data.soc","title":"<code>soc: frequenz.api.common.v1.metrics_pb2.MetricAggregation</code>  <code>property</code>","text":"<p>Battery's overall SoC. In percent (%).</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Data.temperature","title":"<code>temperature: frequenz.api.common.v1.metrics_pb2.MetricAggregation</code>  <code>property</code>","text":"<p>The aggregated values of all the temperature measurements of a battery. In degree Celsius (\u00b0C).</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Error","title":"<code>frequenz.api.microgrid.battery_pb2.Error</code>","text":"<p>             Bases: <code>Message</code></p> <p>Error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Error-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Error.code","title":"<code>code: global___ErrorCode.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error code.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Error.level","title":"<code>level: frequenz.api.microgrid.common_pb2.ErrorLevel.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error severity level.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Error.msg","title":"<code>msg: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.ErrorCode","title":"<code>frequenz.api.microgrid.battery_pb2.ErrorCode</code>","text":"<p>             Bases: <code>_ErrorCode</code></p> <p>Enumerated Battery/BMS error codes.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Metadata","title":"<code>frequenz.api.microgrid.battery_pb2.Metadata</code>","text":"<p>             Bases: <code>Message</code></p> <p>The battery metadata.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Metadata-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Metadata.type","title":"<code>type: frequenz.api.common.v1.components_pb2.BatteryType.ValueType</code>  <code>instance-attribute</code>","text":"<p>The battery type.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Properties","title":"<code>frequenz.api.microgrid.battery_pb2.Properties</code>","text":"<p>             Bases: <code>Message</code></p> <p>Battery properties.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Properties-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Properties.capacity","title":"<code>capacity: builtins.float</code>  <code>instance-attribute</code>","text":"<p>The capacity of the battery. In Watt-hour (Wh).</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.Properties.firmware_ver","title":"<code>firmware_ver: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The firmware version of the battery.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.State","title":"<code>frequenz.api.microgrid.battery_pb2.State</code>","text":"<p>             Bases: <code>Message</code></p> <p>State message.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.State-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.State.component_state","title":"<code>component_state: global___ComponentState.ValueType</code>  <code>instance-attribute</code>","text":"<p>The state of the overall component.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2/#frequenz.api.microgrid.battery_pb2.State.relay_state","title":"<code>relay_state: global___RelayState.ValueType</code>  <code>instance-attribute</code>","text":"<p>The state of the DC relays.</p>"},{"location":"python-reference/frequenz/api/microgrid/battery_pb2_grpc/","title":"battery_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/battery_pb2_grpc/#frequenz.api.microgrid.battery_pb2_grpc","title":"<code>frequenz.api.microgrid.battery_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/common_pb2/","title":"common_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/common_pb2/#frequenz.api.microgrid.common_pb2","title":"<code>frequenz.api.microgrid.common_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/common_pb2/#frequenz.api.microgrid.common_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/common_pb2/#frequenz.api.microgrid.common_pb2.ERROR_LEVEL_CRITICAL","title":"<code>frequenz.api.microgrid.common_pb2.ERROR_LEVEL_CRITICAL: ErrorLevel.ValueType</code>  <code>module-attribute</code>","text":"<p>A severe error that causes the component to fail. Immediate action must be taken.</p>"},{"location":"python-reference/frequenz/api/microgrid/common_pb2/#frequenz.api.microgrid.common_pb2.ERROR_LEVEL_UNSPECIFIED","title":"<code>frequenz.api.microgrid.common_pb2.ERROR_LEVEL_UNSPECIFIED: ErrorLevel.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified component error.</p>"},{"location":"python-reference/frequenz/api/microgrid/common_pb2/#frequenz.api.microgrid.common_pb2.ERROR_LEVEL_WARN","title":"<code>frequenz.api.microgrid.common_pb2.ERROR_LEVEL_WARN: ErrorLevel.ValueType</code>  <code>module-attribute</code>","text":"<p>Action must be taken to prevent a severe error from occurring in the future.</p>"},{"location":"python-reference/frequenz/api/microgrid/common_pb2/#frequenz.api.microgrid.common_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/common_pb2/#frequenz.api.microgrid.common_pb2.ErrorLevel","title":"<code>frequenz.api.microgrid.common_pb2.ErrorLevel</code>","text":"<p>             Bases: <code>_ErrorLevel</code></p> <p>Error levels definitions.</p>"},{"location":"python-reference/frequenz/api/microgrid/common_pb2_grpc/","title":"common_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/common_pb2_grpc/#frequenz.api.microgrid.common_pb2_grpc","title":"<code>frequenz.api.microgrid.common_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/","title":"ev_charger_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2","title":"<code>frequenz.api.microgrid.ev_charger_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_CHARGING_STATION_LOCKED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_CHARGING_STATION_LOCKED: CableState.ValueType</code>  <code>module-attribute</code>","text":"<p>A cable is connected to and locked with the EV charging station.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_CHARGING_STATION_PLUGGED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_CHARGING_STATION_PLUGGED: CableState.ValueType</code>  <code>module-attribute</code>","text":"<p>A cable is connected to the EV charging station, but is not locked with it.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_EV_LOCKED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_EV_LOCKED: CableState.ValueType</code>  <code>module-attribute</code>","text":"<p>A cable is connected to and locked with the EV charging station. The same cable is connected to and locked with the EV.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_EV_PLUGGED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_EV_PLUGGED: CableState.ValueType</code>  <code>module-attribute</code>","text":"<p>A cable is connected to and locked with the EV charging station. The same cable is connected to the EV, but is not locked with it.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_UNPLUGGED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_UNPLUGGED: CableState.ValueType</code>  <code>module-attribute</code>","text":"<p>No cable is connected to the EV charging station.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.CABLE_STATE_UNSPECIFIED: CableState.ValueType</code>  <code>module-attribute</code>","text":"<p>Default state.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_AUTHORIZATION_REJECTED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_AUTHORIZATION_REJECTED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The EV charging station rejected the last authorization.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_CHARGING","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_CHARGING: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The EV charging station is charging an EV.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_DISCHARGING","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_DISCHARGING: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The EV charging station is discharging from an EV into the local microgrid.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_ERROR","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_ERROR: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The EV charging station is in an error state.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_INTERRUPTED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_INTERRUPTED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The EV charging process hes been temporarily interrupted.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_NOT_READY","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_NOT_READY: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The EV charging station is unplugged or RFID is not working.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_READY","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_READY: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The EV charging station is ready and waiting for a charging request</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_STARTING","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_STARTING: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The EV charging station is starting up.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_UNKNOWN","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_UNKNOWN: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The state is provided by the device, but it can not be parsed as any of the above (known) states.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.COMPONENT_STATE_UNSPECIFIED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>Default state. This value is used only when the state information is not available.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CABLE_INVALID","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CABLE_INVALID: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The charging cable could not be locked.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CABLE_LOCK_FAILED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CABLE_LOCK_FAILED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The charging cable could not be locked.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CABLE_LOST","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CABLE_LOST: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The charging cable was unplugged unexpectedly.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CONFIG_ERROR","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CONFIG_ERROR: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The system is incorrectly configured.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CONSUMER_NON_STANDARD","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_CONSUMER_NON_STANDARD: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The connected consumer is not a standard-compliant EV.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_FAULT_CURRENT","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_FAULT_CURRENT: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>A fault current has been detected.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_HARDWARE_INACCESSIBLE","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_HARDWARE_INACCESSIBLE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The system cannot access the internal hardware.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_ILLEGAL_COMPONENT_STATE_REQUESTED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_ILLEGAL_COMPONENT_STATE_REQUESTED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The system received a request to move to an illegal state.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_INTERNAL","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_INTERNAL: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The system has detected an unspecified internal error.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_OVERCURRENT","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_OVERCURRENT: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>DC charging voltage is higher than expected.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_OVERTEMPERATURE","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_OVERTEMPERATURE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Temperature in the charging station is higher than expected.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_OVERVOLTAGE","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_OVERVOLTAGE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>AC supply voltage is higher than expected.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_PLUG_UNKNOWN","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_PLUG_UNKNOWN: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>The charging cable has an unrecognised plug.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_SHORT_CIRCUIT","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_SHORT_CIRCUIT: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>A short circuit has been detected.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_SWITCH_ON_FAULT","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_SWITCH_ON_FAULT: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Something is preventing the DC contactor from being switched on.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_UNDERVOLTAGE","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_UNDERVOLTAGE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>AC supply voltage is lower than expected.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_UNEXPECTED_PILOT_FAILURE","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_UNEXPECTED_PILOT_FAILURE: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>EV has sent an unexpected pilot signal.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ERROR_CODE_UNSPECIFIED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.CableState","title":"<code>frequenz.api.microgrid.ev_charger_pb2.CableState</code>","text":"<p>             Bases: <code>_CableState</code></p> <p>The possible states of the cable connecting an EV charging station and an EV.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ComponentState","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ComponentState</code>","text":"<p>             Bases: <code>_ComponentState</code></p> <p>The possible states of an EV charging station.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Data","title":"<code>frequenz.api.microgrid.ev_charger_pb2.Data</code>","text":"<p>             Bases: <code>Message</code></p> <p>EV charger data.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Data-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Data.ac","title":"<code>ac: frequenz.api.common.v1.metrics.electrical_pb2.AC</code>  <code>property</code>","text":"<p>AC metrics of the EV charging station. Contains data only if AC charging is supported by the EV charging station. (in which case, the type of the EV charging station is TYPE_AC or TYPE_HYBRID)</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Data.dc","title":"<code>dc: frequenz.api.common.v1.metrics.electrical_pb2.DC</code>  <code>property</code>","text":"<p>DC metrics of the EV charging station. Contains data only if DC charging is supported by the EV charging station. (in which case, the type of the EV charging station is TYPE_DC or TYPE_HYBRID)</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Data.temperature","title":"<code>temperature: frequenz.api.common.v1.metrics_pb2.Metric</code>  <code>property</code>","text":"<p>The overall temperature of the EV charger. In degree Celsius (\u00b0C).</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Error","title":"<code>frequenz.api.microgrid.ev_charger_pb2.Error</code>","text":"<p>             Bases: <code>Message</code></p> <p>Error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Error-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Error.code","title":"<code>code: global___ErrorCode.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error code.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Error.level","title":"<code>level: frequenz.api.microgrid.common_pb2.ErrorLevel.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error severity level.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Error.msg","title":"<code>msg: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.ErrorCode","title":"<code>frequenz.api.microgrid.ev_charger_pb2.ErrorCode</code>","text":"<p>             Bases: <code>_ErrorCode</code></p> <p>Enumerated EV charger error codes.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.EvCharger","title":"<code>frequenz.api.microgrid.ev_charger_pb2.EvCharger</code>","text":"<p>             Bases: <code>Message</code></p> <p>EvCharger details</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.EvCharger-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.EvCharger.data","title":"<code>data: global___Data</code>  <code>property</code>","text":"<p>An EV charger data object.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.EvCharger.errors","title":"<code>errors: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]</code>  <code>property</code>","text":"<p>A list of errors encountered the component. An empty list implies no error.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.EvCharger.properties","title":"<code>properties: global___Properties</code>  <code>property</code>","text":"<p>The component properties</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.EvCharger.state","title":"<code>state: global___State</code>  <code>property</code>","text":"<p>The EV charging station's state.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Metadata","title":"<code>frequenz.api.microgrid.ev_charger_pb2.Metadata</code>","text":"<p>             Bases: <code>Message</code></p> <p>The EV charger metadata.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Metadata-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Metadata.type","title":"<code>type: frequenz.api.common.v1.components_pb2.EvChargerType.ValueType</code>  <code>instance-attribute</code>","text":"<p>The EV charger type.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Properties","title":"<code>frequenz.api.microgrid.ev_charger_pb2.Properties</code>","text":"<p>             Bases: <code>Message</code></p> <p>EV charger properties.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Properties-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.Properties.firmware_ver","title":"<code>firmware_ver: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The firmware version of the component.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.State","title":"<code>frequenz.api.microgrid.ev_charger_pb2.State</code>","text":"<p>             Bases: <code>Message</code></p> <p>State message.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.State-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.State.cable_state","title":"<code>cable_state: global___CableState.ValueType</code>  <code>instance-attribute</code>","text":"<p>The state of the charging cable.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2/#frequenz.api.microgrid.ev_charger_pb2.State.component_state","title":"<code>component_state: global___ComponentState.ValueType</code>  <code>instance-attribute</code>","text":"<p>The state of the overall component.</p>"},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2_grpc/","title":"ev_charger_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/ev_charger_pb2_grpc/#frequenz.api.microgrid.ev_charger_pb2_grpc","title":"<code>frequenz.api.microgrid.ev_charger_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/grid_pb2/","title":"grid_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/grid_pb2/#frequenz.api.microgrid.grid_pb2","title":"<code>frequenz.api.microgrid.grid_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/grid_pb2/#frequenz.api.microgrid.grid_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/grid_pb2/#frequenz.api.microgrid.grid_pb2.Metadata","title":"<code>frequenz.api.microgrid.grid_pb2.Metadata</code>","text":"<p>             Bases: <code>Message</code></p> <p>The grid connection point metadata.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/grid_pb2.py</code> <pre><code>  _globals['_METADATA']._serialized_end=104\n# @@protoc_insertion_point(module_scope)\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/grid_pb2/#frequenz.api.microgrid.grid_pb2.Metadata-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/grid_pb2/#frequenz.api.microgrid.grid_pb2.Metadata.rated_fuse_current","title":"<code>rated_fuse_current: builtins.int</code>  <code>instance-attribute</code>","text":"<p>This refers to the maximum amount of electrical current, in amperes, that a fuse at the grid connection point is designed to safely carry under normal operating conditions.</p> <p>This limit applies to currents both flowing in or out of each of the 3 phases individually.</p> <p>In other words, a current i A at one of the phases of the grid connection point must comply with the following constraint: <code>-rated_fuse_current &lt;= i &lt;= rated_fuse_current</code></p>"},{"location":"python-reference/frequenz/api/microgrid/grid_pb2_grpc/","title":"grid_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/grid_pb2_grpc/#frequenz.api.microgrid.grid_pb2_grpc","title":"<code>frequenz.api.microgrid.grid_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/","title":"inverter_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2","title":"<code>frequenz.api.microgrid.inverter_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_CHARGING","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_CHARGING: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The inverter is consuming electrical energy to charge batteries. Applicable to <code>BATTERY</code> and <code>HYBRID</code> inverters only.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_DISCHARGING","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_DISCHARGING: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The inverter is generating electrical energy.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_ERROR","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_ERROR: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The inverter is in a faulty state.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_IDLE","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_IDLE: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The inverter is idle.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_OFF","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_OFF: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>Inverter is switched off.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_STANDBY","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_STANDBY: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The inverter is in a standby state, and is disconnected from the grid. When connected to the grid, it run a few tests, and move to the <code>IDLE</code> state.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_SWITCHING_OFF","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_SWITCHING_OFF: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The inverter is switching off and needs some time to fully shut down.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_SWITCHING_ON","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_SWITCHING_ON: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The inverter is starting up and needs some time to become fully operational.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_UNAVAILABLE","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_UNAVAILABLE: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The inverter is online, but currently unavailable, possibly due to a pre-scheduled maintenance.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_UNKNOWN","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_UNKNOWN: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The state is provided by the device, but it can not be parsed as any of the above (known) states.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.inverter_pb2.COMPONENT_STATE_UNSPECIFIED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>Default value.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.ERROR_CODE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.inverter_pb2.ERROR_CODE_UNSPECIFIED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.ComponentState","title":"<code>frequenz.api.microgrid.inverter_pb2.ComponentState</code>","text":"<p>             Bases: <code>_ComponentState</code></p> <p>Enumerated inverter states.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Data","title":"<code>frequenz.api.microgrid.inverter_pb2.Data</code>","text":"<p>             Bases: <code>Message</code></p> <p>Inverter data.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Data-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Data.ac","title":"<code>ac: frequenz.api.common.v1.metrics.electrical_pb2.AC</code>  <code>property</code>","text":"<p>AC metrics of the inverter.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Data.dc_battery","title":"<code>dc_battery: frequenz.api.common.v1.metrics.electrical_pb2.DC</code>  <code>property</code>","text":"<p>DC metrics for the inverter-battery linkage. This is applicable to <code>BATTERY</code> and <code>HYBRID</code> inverters only.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Data.dc_solar","title":"<code>dc_solar: frequenz.api.common.v1.metrics.electrical_pb2.DC</code>  <code>property</code>","text":"<p>DC metrics for the inverter-PV linkage. This is applicable to <code>SOLAR</code> and <code>HYBRID</code> inverters only.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Data.temperature","title":"<code>temperature: frequenz.api.common.v1.metrics_pb2.Metric</code>  <code>property</code>","text":"<p>The verall temperature of the inverter. In degree Celsius (\u00b0C).</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Error","title":"<code>frequenz.api.microgrid.inverter_pb2.Error</code>","text":"<p>             Bases: <code>Message</code></p> <p>Error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Error-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Error.code","title":"<code>code: global___ErrorCode.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error code.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Error.level","title":"<code>level: frequenz.api.microgrid.common_pb2.ErrorLevel.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error severity level.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Error.msg","title":"<code>msg: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.ErrorCode","title":"<code>frequenz.api.microgrid.inverter_pb2.ErrorCode</code>","text":"<p>             Bases: <code>_ErrorCode</code></p> <p>Enumerated inverter error codes.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Inverter","title":"<code>frequenz.api.microgrid.inverter_pb2.Inverter</code>","text":"<p>             Bases: <code>Message</code></p> <p>Inverter message definition.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Inverter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Inverter.data","title":"<code>data: global___Data</code>  <code>property</code>","text":"<p>An inverter data object.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Inverter.errors","title":"<code>errors: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]</code>  <code>property</code>","text":"<p>A list of errors encountered the component. An empty list implies no error.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Inverter.properties","title":"<code>properties: global___Properties</code>  <code>property</code>","text":"<p>The component properties</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Inverter.state","title":"<code>state: global___State</code>  <code>property</code>","text":"<p>The inverter's state.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Metadata","title":"<code>frequenz.api.microgrid.inverter_pb2.Metadata</code>","text":"<p>             Bases: <code>Message</code></p> <p>The inverter metadata.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Metadata-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Metadata.type","title":"<code>type: frequenz.api.common.v1.components_pb2.InverterType.ValueType</code>  <code>instance-attribute</code>","text":"<p>The inverter type.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Properties","title":"<code>frequenz.api.microgrid.inverter_pb2.Properties</code>","text":"<p>             Bases: <code>Message</code></p> <p>Inverter properties.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Properties-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Properties.firmware_ver","title":"<code>firmware_ver: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The firmware version of the component.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.State","title":"<code>frequenz.api.microgrid.inverter_pb2.State</code>","text":"<p>             Bases: <code>Message</code></p> <p>State message.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.State-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.State.component_state","title":"<code>component_state: global___ComponentState.ValueType</code>  <code>instance-attribute</code>","text":"<p>The state of the overall component.</p>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2/#frequenz.api.microgrid.inverter_pb2.Type","title":"<code>frequenz.api.microgrid.inverter_pb2.Type</code>","text":"<p>             Bases: <code>_Type</code></p> <p>Enumerated inverter types.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/inverter_pb2.py</code> <pre><code>_globals['_INVERTER']._serialized_start=834\n_globals['_INVERTER']._serialized_end=1073\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2_grpc/","title":"inverter_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/inverter_pb2_grpc/#frequenz.api.microgrid.inverter_pb2_grpc","title":"<code>frequenz.api.microgrid.inverter_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/","title":"meter_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2","title":"<code>frequenz.api.microgrid.meter_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.COMPONENT_STATE_ERROR","title":"<code>frequenz.api.microgrid.meter_pb2.COMPONENT_STATE_ERROR: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The meter is in an error state.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.COMPONENT_STATE_OK","title":"<code>frequenz.api.microgrid.meter_pb2.COMPONENT_STATE_OK: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The meter is behaving as expected.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.COMPONENT_STATE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.meter_pb2.COMPONENT_STATE_UNSPECIFIED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified state.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.ERROR_CODE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.meter_pb2.ERROR_CODE_UNSPECIFIED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.TYPE_CONSUMPTION","title":"<code>frequenz.api.microgrid.meter_pb2.TYPE_CONSUMPTION: Type.ValueType</code>  <code>module-attribute</code>","text":"<p>Consumption meter</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.TYPE_FEED_IN","title":"<code>frequenz.api.microgrid.meter_pb2.TYPE_FEED_IN: Type.ValueType</code>  <code>module-attribute</code>","text":"<p>Exported to grid meter</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.TYPE_PRODUCTION","title":"<code>frequenz.api.microgrid.meter_pb2.TYPE_PRODUCTION: Type.ValueType</code>  <code>module-attribute</code>","text":"<p>AC production power meter / inverter production AC power (fallback)</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.TYPE_PURCHASED","title":"<code>frequenz.api.microgrid.meter_pb2.TYPE_PURCHASED: Type.ValueType</code>  <code>module-attribute</code>","text":"<p>Imported power from grid meter</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.ComponentState","title":"<code>frequenz.api.microgrid.meter_pb2.ComponentState</code>","text":"<p>             Bases: <code>_ComponentState</code></p> <p>Enumerated meter states.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Data","title":"<code>frequenz.api.microgrid.meter_pb2.Data</code>","text":"<p>             Bases: <code>Message</code></p> <p>Meter data.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Data-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Data.ac","title":"<code>ac: frequenz.api.common.v1.metrics.electrical_pb2.AC</code>  <code>property</code>","text":"<p>AC metrics of the inverter.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Error","title":"<code>frequenz.api.microgrid.meter_pb2.Error</code>","text":"<p>             Bases: <code>Message</code></p> <p>Error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Error-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Error.code","title":"<code>code: global___ErrorCode.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error code.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Error.level","title":"<code>level: frequenz.api.microgrid.common_pb2.ErrorLevel.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error severity level.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Error.msg","title":"<code>msg: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.ErrorCode","title":"<code>frequenz.api.microgrid.meter_pb2.ErrorCode</code>","text":"<p>             Bases: <code>_ErrorCode</code></p> <p>Enumerated meter error codes.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Metadata","title":"<code>frequenz.api.microgrid.meter_pb2.Metadata</code>","text":"<p>             Bases: <code>Message</code></p> <p>The meter metadata.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Metadata-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Metadata.type","title":"<code>type: global___Type.ValueType</code>  <code>instance-attribute</code>","text":"<p>The meter type.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Meter","title":"<code>frequenz.api.microgrid.meter_pb2.Meter</code>","text":"<p>             Bases: <code>Message</code></p> <p>Meter details</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Meter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Meter.data","title":"<code>data: global___Data</code>  <code>property</code>","text":"<p>A meter data object.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Meter.errors","title":"<code>errors: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]</code>  <code>property</code>","text":"<p>A list of errors encountered the component. An empty list implies no error.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Meter.properties","title":"<code>properties: global___Properties</code>  <code>property</code>","text":"<p>The component properties</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Meter.state","title":"<code>state: global___State</code>  <code>property</code>","text":"<p>The meter's state.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Properties","title":"<code>frequenz.api.microgrid.meter_pb2.Properties</code>","text":"<p>             Bases: <code>Message</code></p> <p>Meter properties.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Properties-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Properties.firmware_ver","title":"<code>firmware_ver: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The firmware version of the component.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.State","title":"<code>frequenz.api.microgrid.meter_pb2.State</code>","text":"<p>             Bases: <code>Message</code></p> <p>State message.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.State-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.State.component_state","title":"<code>component_state: global___ComponentState.ValueType</code>  <code>instance-attribute</code>","text":"<p>The state of the overall component.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2/#frequenz.api.microgrid.meter_pb2.Type","title":"<code>frequenz.api.microgrid.meter_pb2.Type</code>","text":"<p>             Bases: <code>_Type</code></p> <p>Enumerated meter types.</p>"},{"location":"python-reference/frequenz/api/microgrid/meter_pb2_grpc/","title":"meter_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/meter_pb2_grpc/#frequenz.api.microgrid.meter_pb2_grpc","title":"<code>frequenz.api.microgrid.meter_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/","title":"microgrid_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2","title":"<code>frequenz.api.microgrid.microgrid_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Component","title":"<code>frequenz.api.microgrid.microgrid_pb2.Component</code>","text":"<p>             Bases: <code>Message</code></p> <p>A generic message for components. It is used to represent any category of component, with its static parameters.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Component-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Component.category","title":"<code>category: frequenz.api.common.v1.components_pb2.ComponentCategory.ValueType</code>  <code>instance-attribute</code>","text":"<p>The category of the component.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Component.id","title":"<code>id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>A unique identifier for the component.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Component.manufacturer","title":"<code>manufacturer: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The component manufacturer.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Component.model_name","title":"<code>model_name: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The model name of the component.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Component.name","title":"<code>name: builtins.str</code>  <code>instance-attribute</code>","text":"<p>An optional name for the component.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentData","title":"<code>frequenz.api.microgrid.microgrid_pb2.ComponentData</code>","text":"<p>             Bases: <code>Message</code></p> <p>A generic container for data that can originate from any component type.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentData-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentData.id","title":"<code>id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The component ID.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentData.ts","title":"<code>ts: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The timestamp of when the data was measured.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentFilter","title":"<code>frequenz.api.microgrid.microgrid_pb2.ComponentFilter</code>","text":"<p>             Bases: <code>Message</code></p> <p>Parameters for filtering the components.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2.py</code> <pre><code>_globals['_CONNECTIONFILTER']._serialized_start=853\n_globals['_CONNECTIONFILTER']._serialized_end=901\n_globals['_POWERLEVELPARAM']._serialized_start=903\n_globals['_POWERLEVELPARAM']._serialized_end=959\n_globals['_SETPOWERACTIVEPARAM']._serialized_start=961\n_globals['_SETPOWERACTIVEPARAM']._serialized_end=1019\n_globals['_SETPOWERREACTIVEPARAM']._serialized_start=1021\n_globals['_SETPOWERREACTIVEPARAM']._serialized_end=1081\n_globals['_SETBOUNDSPARAM']._serialized_start=1084\n_globals['_SETBOUNDSPARAM']._serialized_end=1500\n_globals['_SETBOUNDSPARAM_TARGETMETRIC']._serialized_start=1257\n_globals['_SETBOUNDSPARAM_TARGETMETRIC']._serialized_end=1500\n_globals['_COMPONENT']._serialized_start=1503\n_globals['_COMPONENT']._serialized_end=2028\n_globals['_COMPONENTLIST']._serialized_start=2030\n_globals['_COMPONENTLIST']._serialized_end=2100\n_globals['_COMPONENTDATA']._serialized_start=2103\n_globals['_COMPONENTDATA']._serialized_end=2603\n_globals['_CONNECTION']._serialized_start=2605\n_globals['_CONNECTION']._serialized_end=2645\n_globals['_CONNECTIONLIST']._serialized_start=2647\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentFilter.categories","title":"<code>categories: google.protobuf.internal.containers.RepeatedScalarFieldContainer[frequenz.api.common.v1.components_pb2.ComponentCategory.ValueType]</code>  <code>property</code>","text":"<p>Return components that have the specified categories only.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentFilter.ids","title":"<code>ids: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>Return components that have the specified IDs only.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentIdParam","title":"<code>frequenz.api.microgrid.microgrid_pb2.ComponentIdParam</code>","text":"<p>             Bases: <code>Message</code></p> <p>Encapsulation of a component ID, intended to be used as a parameter for rpc methods.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2.py</code> <pre><code># @@protoc_insertion_point(module_scope)\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ComponentList","title":"<code>frequenz.api.microgrid.microgrid_pb2.ComponentList</code>","text":"<p>             Bases: <code>Message</code></p> <p>A message containing a list of components, used as a return typ in certain RPC methods.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Connection","title":"<code>frequenz.api.microgrid.microgrid_pb2.Connection</code>","text":"<p>             Bases: <code>Message</code></p> <p>Describes a single connection between components of the microgrid, with direction away from the grid endpoint, meaning it is aligned with positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Connection-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Connection.end","title":"<code>end: builtins.int</code>  <code>instance-attribute</code>","text":"<p><code>id</code> of the component the connection points to</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.Connection.start","title":"<code>start: builtins.int</code>  <code>instance-attribute</code>","text":"<p><code>id</code> of the component the connection starts from</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ConnectionFilter","title":"<code>frequenz.api.microgrid.microgrid_pb2.ConnectionFilter</code>","text":"<p>             Bases: <code>Message</code></p> <p>Parameters for filtering the component connections</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ConnectionFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ConnectionFilter.ends","title":"<code>ends: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>Only return connections that end at the specified component ID(s): if empty, connections with any <code>end</code> will be returned</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ConnectionFilter.starts","title":"<code>starts: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>Only return connections that start from the specified component ID(s): if empty, connections with any <code>start</code> will be returned</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.ConnectionList","title":"<code>frequenz.api.microgrid.microgrid_pb2.ConnectionList</code>","text":"<p>             Bases: <code>Message</code></p> <p>List of connections between components</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata","title":"<code>frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata</code>","text":"<p>             Bases: <code>Message</code></p> <p>Metadata that describes a microgrid.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2.py</code> <pre><code>_MICROGRID.methods_by_name['ListComponents']._options = None\n_MICROGRID.methods_by_name['ListComponents']._serialized_options = b'\\202\\323\\344\\223\\002\\020\\022\\016/v1/components'\n_MICROGRID.methods_by_name['ListConnections']._options = None\n_MICROGRID.methods_by_name['ListConnections']._serialized_options = b'\\202\\323\\344\\223\\002\\021\\022\\017/v1/connections'\n_MICROGRID.methods_by_name['SubscribeComponentData']._options = None\n_MICROGRID.methods_by_name['SubscribeComponentData']._serialized_options = b'\\202\\323\\344\\223\\002\\032\\022\\030/v1/components/{id}/data'\n_MICROGRID.methods_by_name['SetComponentPowerActive']._options = None\n_MICROGRID.methods_by_name['SetComponentPowerActive']._serialized_options = b'\\202\\323\\344\\223\\0026\\0224/v1/components/{component_id}/setPowerActive/{power}'\n_MICROGRID.methods_by_name['SetComponentPowerReactive']._options = None\n_MICROGRID.methods_by_name['SetComponentPowerReactive']._serialized_options = b'\\202\\323\\344\\223\\0028\\0226/v1/components/{component_id}/setPowerReactive/{power}'\n_MICROGRID.methods_by_name['StartComponent']._options = None\n_MICROGRID.methods_by_name['StartComponent']._serialized_options = b'\\202\\323\\344\\223\\002\\033\\022\\031/v1/components/{id}/start'\n_MICROGRID.methods_by_name['HotStandbyComponent']._options = None\n_MICROGRID.methods_by_name['HotStandbyComponent']._serialized_options = b'\\202\\323\\344\\223\\002 \\022\\036/v1/components/{id}/hotStandby'\n_MICROGRID.methods_by_name['ColdStandbyComponent']._options = None\n_MICROGRID.methods_by_name['ColdStandbyComponent']._serialized_options = b'\\202\\323\\344\\223\\002!\\022\\037/v1/components/{id}/coldStandby'\n_MICROGRID.methods_by_name['StopComponent']._options = None\n_MICROGRID.methods_by_name['StopComponent']._serialized_options = b'\\202\\323\\344\\223\\002\\032\\022\\030/v1/components/{id}/stop'\n_MICROGRID.methods_by_name['AckComponentError']._options = None\n_MICROGRID.methods_by_name['AckComponentError']._serialized_options = b'\\202\\323\\344\\223\\002\\036\\022\\034/v1/components/{id}/errorAck'\n_globals['_MICROGRIDMETADATA']._serialized_start=611\n_globals['_MICROGRIDMETADATA']._serialized_end=713\n_globals['_COMPONENTFILTER']._serialized_start=715\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata.location","title":"<code>location: frequenz.api.common.v1.location_pb2.Location</code>  <code>property</code>","text":"<p>The location of the microgrid, in geographical co-ordinates.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata.microgrid_id","title":"<code>microgrid_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The microgrid ID. This is a natural number that uniquely identifies a given microgrid.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.PowerLevelParam","title":"<code>frequenz.api.microgrid.microgrid_pb2.PowerLevelParam</code>","text":"<p>             Bases: <code>Message</code></p> <p>Parameters for setting the charge/discharge power of an appropriate component.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.PowerLevelParam-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.PowerLevelParam.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The ID of the component to set the output power of.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.PowerLevelParam.power_w","title":"<code>power_w: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The output power level, in watts. This is always a +ve integer. The sign of the power level is controlled by the implementations of the <code>Charge</code> and <code>Discharge</code> RPC methods.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetBoundsParam","title":"<code>frequenz.api.microgrid.microgrid_pb2.SetBoundsParam</code>","text":"<p>             Bases: <code>Message</code></p> <p>Parameters for setting bounds of a given metric of a given component.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetBoundsParam-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetBoundsParam.bounds","title":"<code>bounds: frequenz.api.common.v1.metrics_pb2.Bounds</code>  <code>property</code>","text":"<p>The bounds for the target metric.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetBoundsParam.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The ID of the target component.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetBoundsParam.target_metric","title":"<code>target_metric: global___SetBoundsParam.TargetMetric.ValueType</code>  <code>instance-attribute</code>","text":"<p>The target metric whose bounds have to be set.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetBoundsParam-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetBoundsParam.TargetMetric","title":"<code>TargetMetric</code>","text":"<p>             Bases: <code>_TargetMetric</code></p> <p>An enumerated list of metrics whose bounds can be set.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam","title":"<code>frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam</code>","text":"<p>             Bases: <code>Message</code></p> <p>Parameters for setting the active power of an appropriate component using the <code>SetPowerActive</code> RPC.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The ID of the component to set the output active power of.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam.power","title":"<code>power: builtins.float</code>  <code>instance-attribute</code>","text":"<p>The output active power level, in watts. -ve values are for discharging, and +ve values are for charging.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam","title":"<code>frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam</code>","text":"<p>             Bases: <code>Message</code></p> <p>Parameters for setting the reactive power of an appropriate component using the <code>SetPowerReactive</code> RPC.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The ID of the component to set the output reactive power of.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2/#frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam.power","title":"<code>power: builtins.float</code>  <code>instance-attribute</code>","text":"<p>The output reactive power level, in VAr. -ve values are for inductive (lagging) power , and +ve values are for  capacitive (leading) power.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/","title":"microgrid_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc","title":"<code>frequenz.api.microgrid.microgrid_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.Microgrid","title":"<code>frequenz.api.microgrid.microgrid_pb2_grpc.Microgrid</code>","text":"<p>             Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>class Microgrid(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    @staticmethod\n    def GetMicrogridMetadata(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/GetMicrogridMetadata',\n            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.MicrogridMetadata.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListComponents(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/ListComponents',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentFilter.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentList.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListConnections(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/ListConnections',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionFilter.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionList.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def SubscribeComponentData(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(request, target, '/frequenz.api.microgrid.Microgrid/SubscribeComponentData',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentData.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AddComponentExclusionBounds(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/AddComponentExclusionBounds',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString,\n            google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AddComponentInclusionBounds(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/AddComponentInclusionBounds',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString,\n            google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def SetComponentPowerActive(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/SetComponentPowerActive',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerActiveParam.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def SetComponentPowerReactive(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/SetComponentPowerReactive',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerReactiveParam.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def StartComponent(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/StartComponent',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def HotStandbyComponent(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/HotStandbyComponent',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ColdStandbyComponent(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/ColdStandbyComponent',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def StopComponent(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/StopComponent',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AckComponentError(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/AckComponentError',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub","title":"<code>frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call effectively skips that action.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ColdStandbyComponent(self, request, context):\n        \"\"\"Sets the given component into a cold-standby state, from which it can\n        return into an operational state within at most 2 minutes.\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter: Checks if AC and DC relays are closed, then\n        * sets power to 0, and\n        * opens AC relays\n\n        If any of the checks mentioned above fails, then the method call returns an\n        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call efffectively skips that action.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def StopComponent(self, request, context):\n        \"\"\"Stops the component completely, potentially disengaging its power\n        electronics controller(s).\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter:\n        * Brings component to the cold-standby state\n        * opens DC relays\n\n        * Battery: Checks if the power output is 0, then\n        * opens DC relays\n\n        * Relays:\n        * opens relays\n\n        * Precharge Modules:\n        * opens the DC relays.\n\n        If any of the checks mentioned above fails, then the method call returns an\n        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call effectively skips that action.\n\n        If a feature required to perform an action is missing, then that action is\n        skipped.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def AckComponentError(self, request, context):\n        \"\"\"Acknowledges any recoverable error reported by the component, and brings it\n        back to the stopped or cold-standby state.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n\ndef add_MicrogridServicer_to_server(servicer, server):\n    rpc_method_handlers = {\n            'GetMicrogridMetadata': grpc.unary_unary_rpc_method_handler(\n                    servicer.GetMicrogridMetadata,\n                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.MicrogridMetadata.SerializeToString,\n            ),\n            'ListComponents': grpc.unary_unary_rpc_method_handler(\n                    servicer.ListComponents,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentFilter.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentList.SerializeToString,\n            ),\n            'ListConnections': grpc.unary_unary_rpc_method_handler(\n                    servicer.ListConnections,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionFilter.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionList.SerializeToString,\n            ),\n            'SubscribeComponentData': grpc.unary_stream_rpc_method_handler(\n                    servicer.SubscribeComponentData,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentData.SerializeToString,\n            ),\n            'AddComponentExclusionBounds': grpc.unary_unary_rpc_method_handler(\n                    servicer.AddComponentExclusionBounds,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.FromString,\n                    response_serializer=google_dot_protobuf_dot_timestamp__pb2.Timestamp.SerializeToString,\n            ),\n            'AddComponentInclusionBounds': grpc.unary_unary_rpc_method_handler(\n                    servicer.AddComponentInclusionBounds,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.FromString,\n                    response_serializer=google_dot_protobuf_dot_timestamp__pb2.Timestamp.SerializeToString,\n            ),\n            'SetComponentPowerActive': grpc.unary_unary_rpc_method_handler(\n                    servicer.SetComponentPowerActive,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerActiveParam.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'SetComponentPowerReactive': grpc.unary_unary_rpc_method_handler(\n                    servicer.SetComponentPowerReactive,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerReactiveParam.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'StartComponent': grpc.unary_unary_rpc_method_handler(\n                    servicer.StartComponent,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'HotStandbyComponent': grpc.unary_unary_rpc_method_handler(\n                    servicer.HotStandbyComponent,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'ColdStandbyComponent': grpc.unary_unary_rpc_method_handler(\n                    servicer.ColdStandbyComponent,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'StopComponent': grpc.unary_unary_rpc_method_handler(\n                    servicer.StopComponent,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'AckComponentError': grpc.unary_unary_rpc_method_handler(\n                    servicer.AckComponentError,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n    }\n    generic_handler = grpc.method_handlers_generic_handler(\n            'frequenz.api.microgrid.Microgrid', rpc_method_handlers)\n    server.add_generic_rpc_handlers((generic_handler,))\n\n\n # This class is part of an EXPERIMENTAL API.\nclass Microgrid(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    @staticmethod\n    def GetMicrogridMetadata(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/GetMicrogridMetadata',\n            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.MicrogridMetadata.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListComponents(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/ListComponents',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentFilter.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentList.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListConnections(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/ListConnections',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionFilter.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionList.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def SubscribeComponentData(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(request, target, '/frequenz.api.microgrid.Microgrid/SubscribeComponentData',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentData.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AddComponentExclusionBounds(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/AddComponentExclusionBounds',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString,\n            google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AddComponentInclusionBounds(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/AddComponentInclusionBounds',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString,\n            google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def SetComponentPowerActive(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/SetComponentPowerActive',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerActiveParam.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def SetComponentPowerReactive(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.Microgrid/SetComponentPowerReactive',\n            frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerReactiveParam.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.AckComponentError","title":"<code>AckComponentError: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Acknowledges any recoverable error reported by the component, and brings it back to the stopped or cold-standby state.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.AddComponentExclusionBounds","title":"<code>AddComponentExclusionBounds: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.SetBoundsParam, google.protobuf.timestamp_pb2.Timestamp]</code>  <code>instance-attribute</code>","text":"<p>Adds exclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given exclusion bounds will stay in effect.</p> <p>Exclusion bounds refer to the range of values that are disallowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraints <code>value &lt;= lower</code> OR <code>upper &lt;= value</code>.</p> <p>Exclusion bounds are a useful tool for enhancing the performance of a system. They can be used to restrict the acceptance of commands that fall below a certain threshold, which can help ensure the smooth functioning of the system. E.g., exclusion bounds can be set to limit the minimum charging power to a sufficiently high level, preventing a peak-shaver client from sending charge powers that are too low when a DC heater client is executing a charge pulse. This can significantly improve the overall performance of the DC heating mechanism.</p> <p>If multiple exclusion bounds have been provided bor a metric, then the aggregated lower and upper exclusion bounds are calculated as follows: lower: the minimum of all lower exclusion bounds upper: the maximum of all upper exclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_inclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>  inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\n               exclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and wil be rejected ==== vales here are allowed and will be accepted</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.AddComponentInclusionBounds","title":"<code>AddComponentInclusionBounds: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.SetBoundsParam, google.protobuf.timestamp_pb2.Timestamp]</code>  <code>instance-attribute</code>","text":"<p>Adds inclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given inclusion bounds will stay in effect.</p> <p>Inclusion bounds refer to the range of values that are allowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraint <code>lower &lt;= value &lt;= upper</code>.</p> <p>If multiple inclusion bounds have been provided bor a metric, then the aggregated lower and upper inclusion bounds are calculated as follows: lower: the maximum of all lower inclusion bounds upper: the minimum of all upper inclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_exclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>  inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\n               exclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and wil be rejected ==== vales here are allowed and will be accepted</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.ColdStandbyComponent","title":"<code>ColdStandbyComponent: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Sets the given component into a cold-standby state, from which it can return into an operational state within at most 2 minutes.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then</li> <li>sets power to 0, and</li> <li>opens AC relays</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call efffectively skips that action.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.GetMicrogridMetadata","title":"<code>GetMicrogridMetadata: grpc.aio.UnaryUnaryMultiCallable[google.protobuf.empty_pb2.Empty, frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata]</code>  <code>instance-attribute</code>","text":"<p>/ Returns the microgrid metadata / The metadata consists of information that describes the overall / microgrid, as opposed to its components, / e.g., the microgrid ID, location.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.HotStandbyComponent","title":"<code>HotStandbyComponent: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Sets the given component into a hot-standby state, from which it can return into an operational state within at most 5 seconds.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then</li> <li>sets power to 0</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.ListComponents","title":"<code>ListComponents: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentFilter, frequenz.api.microgrid.microgrid_pb2.ComponentList]</code>  <code>instance-attribute</code>","text":"<p>List components in the local microgrid, optionally filtered by a given list of component IDs and component categories.</p> <p>If provided, the filters for component IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [  <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code>,  <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code> OR <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>.</p> <p>If a filter list is empty, then that filter is not applied.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.ListConnections","title":"<code>ListConnections: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ConnectionFilter, frequenz.api.microgrid.microgrid_pb2.ConnectionList]</code>  <code>instance-attribute</code>","text":"<p>Returns a list of the connections between components as <code>(start, end)</code> pairs of connection IDs, where the direction of individual connections is always away from the grid endpoint, i.e. aligned with the direction of positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p> <p>The request may be filtered by <code>start</code>/<code>end</code> component(s) of individual connections.  If provided, the <code>start</code> and <code>end</code> filters have an <code>AND</code> relationship between each other, meaning that they are applied serially, but an <code>OR</code> relationship with other elements in the same list. For example, if <code>start</code> = <code>[1, 2, 3]</code>, and <code>end</code> = <code>[4, 5, 6]</code>, then the result should have all the connections where * each <code>start</code> component ID is either <code>1</code>, <code>2</code>, OR <code>3</code>,  AND * each <code>end</code> component ID is either <code>4</code>, <code>5</code>, OR <code>6</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.SetComponentPowerActive","title":"<code>SetComponentPowerActive: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Sets the active power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 W. E.g., an inverter may have a resolution of 88 W. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Sends the discharge command to the inverter, making it deliver  AC power.</li> </ul>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.SetComponentPowerReactive","title":"<code>SetComponentPowerReactive: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Sets the reactive power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 VAr. E.g., an inverter may have a resolution of 88 VAr. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.StartComponent","title":"<code>StartComponent: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Starts the component, and brings it into a state where it is immediately operational.</p> <p>Performs the following sequence of actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>closes DC relays, if the feature is available</li> <li>closes AC relays</li> <li> <p>sets power output to 0</p> </li> <li> <p>Battery: Checks if DC relays are open, then</p> </li> <li> <p>closes DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>closes relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>starts the precharge process, and eventually closes the DC relays.</li> </ul> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.StopComponent","title":"<code>StopComponent: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Stops the component completely, potentially disengaging its power electronics controller(s).</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>Brings component to the cold-standby state</li> <li> <p>opens DC relays</p> </li> <li> <p>Battery: Checks if the power output is 0, then</p> </li> <li> <p>opens DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>opens relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>opens the DC relays.</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridAsyncStub.SubscribeComponentData","title":"<code>SubscribeComponentData: grpc.aio.UnaryStreamMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, frequenz.api.microgrid.microgrid_pb2.ComponentData]</code>  <code>instance-attribute</code>","text":"<p>Returns a stream containing data from a component with a given ID.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer","title":"<code>frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer</code>","text":"<p>             Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>class MicrogridServicer(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def GetMicrogridMetadata(self, request, context):\n        \"\"\"/ Returns the microgrid metadata\n        / The metadata consists of information that describes the overall\n        / microgrid, as opposed to its components,\n        / e.g., the microgrid ID, location.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ListComponents(self, request, context):\n        \"\"\"List components in the local microgrid, optionally filtered by a given list\n        of component IDs and component categories.\n\n        If provided, the filters for component IDs and categories have an `AND`\n        relationship with one another, meaning that they are applied serially,\n        but the elements within a single filter list have an `OR` relationship with\n        each other.\n        E.g., if `ids` = [1, 2, 3], and `categories` = [\n        `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,\n        `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],\n        then the results will consist of elements that\n        have the IDs 1, OR 2, OR 3,\n        AND\n        are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR\n        `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.\n\n        If a filter list is empty, then that filter is not applied.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ListConnections(self, request, context):\n        \"\"\"Returns a list of the connections between components as `(start, end)`\n        pairs of connection IDs, where the direction of individual connections\n        is always away from the grid endpoint, i.e. aligned with the direction\n        of positive current according to the passive sign convention:\n        https://en.wikipedia.org/wiki/Passive_sign_convention\n\n        The request may be filtered by `start`/`end` component(s) of individual\n        connections.  If provided, the `start` and `end` filters have an `AND`\n        relationship between each other, meaning that they are applied serially,\n        but an `OR` relationship with other elements in the same list.\n        For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the\n        result should have all the connections where\n        * each `start` component ID is either `1`, `2`, OR `3`,\n        AND\n        * each `end` component ID is either `4`, `5`, OR `6`.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def SubscribeComponentData(self, request, context):\n        \"\"\"Returns a stream containing data from a component with a given ID.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def AddComponentExclusionBounds(self, request, context):\n        \"\"\"Adds exclusion bounds for a given metric of a given component, and returns\n        the UTC timestamp until which the given exclusion bounds will stay in\n        effect.\n\n        Exclusion bounds refer to the range of values that are disallowed for the\n        metric. If these bounds for a metric are [`lower`, `upper`], then this\n        metric's `value` needs to comply with the constraints\n        `value &lt;= lower` OR `upper &lt;= value`.\n\n        Exclusion bounds are a useful tool for enhancing the performance of a\n        system. They can be used to restrict the acceptance of commands that fall\n        below a certain threshold, which can help ensure the smooth functioning of\n        the system.\n        E.g., exclusion bounds can be set to limit the minimum charging power to a\n        sufficiently high level, preventing a peak-shaver client from sending\n        charge powers that are too low when a DC heater client is executing a\n        charge pulse. This can significantly improve the overall performance of the\n        DC heating mechanism.\n\n\n        If multiple exclusion bounds have been provided bor a metric, then the\n        aggregated lower and upper exclusion bounds are calculated as follows:\n        lower: the minimum of all lower exclusion bounds\n        upper: the maximum of all upper exclusion bounds\n\n        It is important to note that these bounds work together with\n        `system_inclusion_bounds`.\n\n        E.g., for the system to accept a charge command,\n        clients need to request power values within the bounds\n        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.\n        This means that clients can only request charge commands with values that\n        are within the `system_inclusion_bounds`, but not within\n        `system_exclusion_bounds`.\n        Similarly, for the system to accept a discharge command,\n        clients need to request power values within the bounds\n        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.\n\n        The following diagram illustrates the relationship between the bounds.\n        ```\n        inclusion.lower                              inclusion.upper\n        &lt;-------|============|------------------|============|---------&gt;\n        exclusion.lower    exclusion.upper\n        ```\n        ---- values here are disallowed and wil be rejected\n        ==== vales here are allowed and will be accepted\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def AddComponentInclusionBounds(self, request, context):\n        \"\"\"Adds inclusion bounds for a given metric of a given component, and returns\n        the UTC timestamp until which the given inclusion bounds will stay in\n        effect.\n\n        Inclusion bounds refer to the range of values that are allowed for the\n        metric. If these bounds for a metric are [`lower`, `upper`], then this\n        metric's `value` needs to comply with the constraint\n        `lower &lt;= value &lt;= upper`.\n\n        If multiple inclusion bounds have been provided bor a metric, then the\n        aggregated lower and upper inclusion bounds are calculated as follows:\n        lower: the maximum of all lower inclusion bounds\n        upper: the minimum of all upper inclusion bounds\n\n        It is important to note that these bounds work together with\n        `system_exclusion_bounds`.\n\n        E.g., for the system to accept a charge command,\n        clients need to request power values within the bounds\n        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.\n        This means that clients can only request charge commands with values that\n        are within the `system_inclusion_bounds`, but not within\n        `system_exclusion_bounds`.\n        Similarly, for the system to accept a discharge command,\n        clients need to request power values within the bounds\n        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.\n\n        The following diagram illustrates the relationship between the bounds.\n        ```\n        inclusion.lower                              inclusion.upper\n        &lt;-------|============|------------------|============|---------&gt;\n        exclusion.lower    exclusion.upper\n        ```\n        ---- values here are disallowed and wil be rejected\n        ==== vales here are allowed and will be accepted\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def SetComponentPowerActive(self, request, context):\n        \"\"\"Sets the active power output of a component with a given ID, provided the\n        component supports it.\n\n        Note that the target component may have a resolution of more than 1 W.\n        E.g., an inverter may have a resolution of 88 W.\n        In such cases, the magnitude of power will be floored to the nearest\n        multiple of the resolution.\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter: Sends the discharge command to the inverter, making it deliver\n        AC power.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def SetComponentPowerReactive(self, request, context):\n        \"\"\"Sets the reactive power output of a component with a given ID, provided the\n        component supports it.\n\n        Note that the target component may have a resolution of more than 1 VAr.\n        E.g., an inverter may have a resolution of 88 VAr.\n        In such cases, the magnitude of power will be floored to the nearest\n        multiple of the resolution.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def StartComponent(self, request, context):\n        \"\"\"Starts the component, and brings it into a state where it is immediately\n        operational.\n\n        Performs the following sequence of actions for the following component\n        categories:\n\n        * Inverter:\n        * closes DC relays, if the feature is available\n        * closes AC relays\n        * sets power output to 0\n\n        * Battery: Checks if DC relays are open, then\n        * closes DC relays\n\n        * Relays:\n        * closes relays\n\n        * Precharge Modules:\n        * starts the precharge process, and eventually closes the DC relays.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call effectively skips that action.\n\n        If a feature required to perform an action is missing, then that action is\n        skipped.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def HotStandbyComponent(self, request, context):\n        \"\"\"Sets the given component into a hot-standby state, from which it can return\n        into an operational state within at most 5 seconds.\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter: Checks if AC and DC relays are closed, then\n        * sets power to 0\n\n        If any of the checks mentioned above fails, then the method call returns an\n        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call effectively skips that action.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ColdStandbyComponent(self, request, context):\n        \"\"\"Sets the given component into a cold-standby state, from which it can\n        return into an operational state within at most 2 minutes.\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter: Checks if AC and DC relays are closed, then\n        * sets power to 0, and\n        * opens AC relays\n\n        If any of the checks mentioned above fails, then the method call returns an\n        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call efffectively skips that action.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def StopComponent(self, request, context):\n        \"\"\"Stops the component completely, potentially disengaging its power\n        electronics controller(s).\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter:\n        * Brings component to the cold-standby state\n        * opens DC relays\n\n        * Battery: Checks if the power output is 0, then\n        * opens DC relays\n\n        * Relays:\n        * opens relays\n\n        * Precharge Modules:\n        * opens the DC relays.\n\n        If any of the checks mentioned above fails, then the method call returns an\n        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call effectively skips that action.\n\n        If a feature required to perform an action is missing, then that action is\n        skipped.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def AckComponentError(self, request, context):\n        \"\"\"Acknowledges any recoverable error reported by the component, and brings it\n        back to the stopped or cold-standby state.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.AckComponentError","title":"<code>AckComponentError(request, context)</code>","text":"<p>Acknowledges any recoverable error reported by the component, and brings it back to the stopped or cold-standby state.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def AckComponentError(self, request, context):\n    \"\"\"Acknowledges any recoverable error reported by the component, and brings it\n    back to the stopped or cold-standby state.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.AddComponentExclusionBounds","title":"<code>AddComponentExclusionBounds(request, context)</code>","text":"<p>Adds exclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given exclusion bounds will stay in effect.</p> <p>Exclusion bounds refer to the range of values that are disallowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraints <code>value &lt;= lower</code> OR <code>upper &lt;= value</code>.</p> <p>Exclusion bounds are a useful tool for enhancing the performance of a system. They can be used to restrict the acceptance of commands that fall below a certain threshold, which can help ensure the smooth functioning of the system. E.g., exclusion bounds can be set to limit the minimum charging power to a sufficiently high level, preventing a peak-shaver client from sending charge powers that are too low when a DC heater client is executing a charge pulse. This can significantly improve the overall performance of the DC heating mechanism.</p> <p>If multiple exclusion bounds have been provided bor a metric, then the aggregated lower and upper exclusion bounds are calculated as follows: lower: the minimum of all lower exclusion bounds upper: the maximum of all upper exclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_inclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\nexclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and wil be rejected ==== vales here are allowed and will be accepted</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def AddComponentExclusionBounds(self, request, context):\n    \"\"\"Adds exclusion bounds for a given metric of a given component, and returns\n    the UTC timestamp until which the given exclusion bounds will stay in\n    effect.\n\n    Exclusion bounds refer to the range of values that are disallowed for the\n    metric. If these bounds for a metric are [`lower`, `upper`], then this\n    metric's `value` needs to comply with the constraints\n    `value &lt;= lower` OR `upper &lt;= value`.\n\n    Exclusion bounds are a useful tool for enhancing the performance of a\n    system. They can be used to restrict the acceptance of commands that fall\n    below a certain threshold, which can help ensure the smooth functioning of\n    the system.\n    E.g., exclusion bounds can be set to limit the minimum charging power to a\n    sufficiently high level, preventing a peak-shaver client from sending\n    charge powers that are too low when a DC heater client is executing a\n    charge pulse. This can significantly improve the overall performance of the\n    DC heating mechanism.\n\n\n    If multiple exclusion bounds have been provided bor a metric, then the\n    aggregated lower and upper exclusion bounds are calculated as follows:\n    lower: the minimum of all lower exclusion bounds\n    upper: the maximum of all upper exclusion bounds\n\n    It is important to note that these bounds work together with\n    `system_inclusion_bounds`.\n\n    E.g., for the system to accept a charge command,\n    clients need to request power values within the bounds\n    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.\n    This means that clients can only request charge commands with values that\n    are within the `system_inclusion_bounds`, but not within\n    `system_exclusion_bounds`.\n    Similarly, for the system to accept a discharge command,\n    clients need to request power values within the bounds\n    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.\n\n    The following diagram illustrates the relationship between the bounds.\n    ```\n    inclusion.lower                              inclusion.upper\n    &lt;-------|============|------------------|============|---------&gt;\n    exclusion.lower    exclusion.upper\n    ```\n    ---- values here are disallowed and wil be rejected\n    ==== vales here are allowed and will be accepted\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.AddComponentInclusionBounds","title":"<code>AddComponentInclusionBounds(request, context)</code>","text":"<p>Adds inclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given inclusion bounds will stay in effect.</p> <p>Inclusion bounds refer to the range of values that are allowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraint <code>lower &lt;= value &lt;= upper</code>.</p> <p>If multiple inclusion bounds have been provided bor a metric, then the aggregated lower and upper inclusion bounds are calculated as follows: lower: the maximum of all lower inclusion bounds upper: the minimum of all upper inclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_exclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\nexclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and wil be rejected ==== vales here are allowed and will be accepted</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def AddComponentInclusionBounds(self, request, context):\n    \"\"\"Adds inclusion bounds for a given metric of a given component, and returns\n    the UTC timestamp until which the given inclusion bounds will stay in\n    effect.\n\n    Inclusion bounds refer to the range of values that are allowed for the\n    metric. If these bounds for a metric are [`lower`, `upper`], then this\n    metric's `value` needs to comply with the constraint\n    `lower &lt;= value &lt;= upper`.\n\n    If multiple inclusion bounds have been provided bor a metric, then the\n    aggregated lower and upper inclusion bounds are calculated as follows:\n    lower: the maximum of all lower inclusion bounds\n    upper: the minimum of all upper inclusion bounds\n\n    It is important to note that these bounds work together with\n    `system_exclusion_bounds`.\n\n    E.g., for the system to accept a charge command,\n    clients need to request power values within the bounds\n    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.\n    This means that clients can only request charge commands with values that\n    are within the `system_inclusion_bounds`, but not within\n    `system_exclusion_bounds`.\n    Similarly, for the system to accept a discharge command,\n    clients need to request power values within the bounds\n    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.\n\n    The following diagram illustrates the relationship between the bounds.\n    ```\n    inclusion.lower                              inclusion.upper\n    &lt;-------|============|------------------|============|---------&gt;\n    exclusion.lower    exclusion.upper\n    ```\n    ---- values here are disallowed and wil be rejected\n    ==== vales here are allowed and will be accepted\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.ColdStandbyComponent","title":"<code>ColdStandbyComponent(request, context)</code>","text":"<p>Sets the given component into a cold-standby state, from which it can return into an operational state within at most 2 minutes.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then</li> <li>sets power to 0, and</li> <li>opens AC relays</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call efffectively skips that action.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def ColdStandbyComponent(self, request, context):\n    \"\"\"Sets the given component into a cold-standby state, from which it can\n    return into an operational state within at most 2 minutes.\n\n    Performs the following sequence actions for the following component\n    categories:\n\n    * Inverter: Checks if AC and DC relays are closed, then\n    * sets power to 0, and\n    * opens AC relays\n\n    If any of the checks mentioned above fails, then the method call returns an\n    error.\n\n    If any of the above mentioned actions for a given component has already\n    been performed, then this method call efffectively skips that action.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.GetMicrogridMetadata","title":"<code>GetMicrogridMetadata(request, context)</code>","text":"<p>/ Returns the microgrid metadata / The metadata consists of information that describes the overall / microgrid, as opposed to its components, / e.g., the microgrid ID, location.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def GetMicrogridMetadata(self, request, context):\n    \"\"\"/ Returns the microgrid metadata\n    / The metadata consists of information that describes the overall\n    / microgrid, as opposed to its components,\n    / e.g., the microgrid ID, location.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.HotStandbyComponent","title":"<code>HotStandbyComponent(request, context)</code>","text":"<p>Sets the given component into a hot-standby state, from which it can return into an operational state within at most 5 seconds.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then</li> <li>sets power to 0</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def HotStandbyComponent(self, request, context):\n    \"\"\"Sets the given component into a hot-standby state, from which it can return\n    into an operational state within at most 5 seconds.\n\n    Performs the following sequence actions for the following component\n    categories:\n\n    * Inverter: Checks if AC and DC relays are closed, then\n    * sets power to 0\n\n    If any of the checks mentioned above fails, then the method call returns an\n    error.\n\n    If any of the above mentioned actions for a given component has already\n    been performed, then this method call effectively skips that action.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.ListComponents","title":"<code>ListComponents(request, context)</code>","text":"<p>List components in the local microgrid, optionally filtered by a given list of component IDs and component categories.</p> <p>If provided, the filters for component IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [ <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code>, <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code> OR <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>.</p> <p>If a filter list is empty, then that filter is not applied.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def ListComponents(self, request, context):\n    \"\"\"List components in the local microgrid, optionally filtered by a given list\n    of component IDs and component categories.\n\n    If provided, the filters for component IDs and categories have an `AND`\n    relationship with one another, meaning that they are applied serially,\n    but the elements within a single filter list have an `OR` relationship with\n    each other.\n    E.g., if `ids` = [1, 2, 3], and `categories` = [\n    `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,\n    `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],\n    then the results will consist of elements that\n    have the IDs 1, OR 2, OR 3,\n    AND\n    are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR\n    `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.\n\n    If a filter list is empty, then that filter is not applied.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.ListConnections","title":"<code>ListConnections(request, context)</code>","text":"<p>Returns a list of the connections between components as <code>(start, end)</code> pairs of connection IDs, where the direction of individual connections is always away from the grid endpoint, i.e. aligned with the direction of positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p> <p>The request may be filtered by <code>start</code>/<code>end</code> component(s) of individual connections.  If provided, the <code>start</code> and <code>end</code> filters have an <code>AND</code> relationship between each other, meaning that they are applied serially, but an <code>OR</code> relationship with other elements in the same list. For example, if <code>start</code> = <code>[1, 2, 3]</code>, and <code>end</code> = <code>[4, 5, 6]</code>, then the result should have all the connections where * each <code>start</code> component ID is either <code>1</code>, <code>2</code>, OR <code>3</code>, AND * each <code>end</code> component ID is either <code>4</code>, <code>5</code>, OR <code>6</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def ListConnections(self, request, context):\n    \"\"\"Returns a list of the connections between components as `(start, end)`\n    pairs of connection IDs, where the direction of individual connections\n    is always away from the grid endpoint, i.e. aligned with the direction\n    of positive current according to the passive sign convention:\n    https://en.wikipedia.org/wiki/Passive_sign_convention\n\n    The request may be filtered by `start`/`end` component(s) of individual\n    connections.  If provided, the `start` and `end` filters have an `AND`\n    relationship between each other, meaning that they are applied serially,\n    but an `OR` relationship with other elements in the same list.\n    For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the\n    result should have all the connections where\n    * each `start` component ID is either `1`, `2`, OR `3`,\n    AND\n    * each `end` component ID is either `4`, `5`, OR `6`.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.SetComponentPowerActive","title":"<code>SetComponentPowerActive(request, context)</code>","text":"<p>Sets the active power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 W. E.g., an inverter may have a resolution of 88 W. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Sends the discharge command to the inverter, making it deliver AC power.</li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def SetComponentPowerActive(self, request, context):\n    \"\"\"Sets the active power output of a component with a given ID, provided the\n    component supports it.\n\n    Note that the target component may have a resolution of more than 1 W.\n    E.g., an inverter may have a resolution of 88 W.\n    In such cases, the magnitude of power will be floored to the nearest\n    multiple of the resolution.\n\n    Performs the following sequence actions for the following component\n    categories:\n\n    * Inverter: Sends the discharge command to the inverter, making it deliver\n    AC power.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.SetComponentPowerReactive","title":"<code>SetComponentPowerReactive(request, context)</code>","text":"<p>Sets the reactive power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 VAr. E.g., an inverter may have a resolution of 88 VAr. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def SetComponentPowerReactive(self, request, context):\n    \"\"\"Sets the reactive power output of a component with a given ID, provided the\n    component supports it.\n\n    Note that the target component may have a resolution of more than 1 VAr.\n    E.g., an inverter may have a resolution of 88 VAr.\n    In such cases, the magnitude of power will be floored to the nearest\n    multiple of the resolution.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.StartComponent","title":"<code>StartComponent(request, context)</code>","text":"<p>Starts the component, and brings it into a state where it is immediately operational.</p> <p>Performs the following sequence of actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>closes DC relays, if the feature is available</li> <li>closes AC relays</li> <li> <p>sets power output to 0</p> </li> <li> <p>Battery: Checks if DC relays are open, then</p> </li> <li> <p>closes DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>closes relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>starts the precharge process, and eventually closes the DC relays.</li> </ul> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def StartComponent(self, request, context):\n    \"\"\"Starts the component, and brings it into a state where it is immediately\n    operational.\n\n    Performs the following sequence of actions for the following component\n    categories:\n\n    * Inverter:\n    * closes DC relays, if the feature is available\n    * closes AC relays\n    * sets power output to 0\n\n    * Battery: Checks if DC relays are open, then\n    * closes DC relays\n\n    * Relays:\n    * closes relays\n\n    * Precharge Modules:\n    * starts the precharge process, and eventually closes the DC relays.\n\n    If any of the above mentioned actions for a given component has already\n    been performed, then this method call effectively skips that action.\n\n    If a feature required to perform an action is missing, then that action is\n    skipped.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.StopComponent","title":"<code>StopComponent(request, context)</code>","text":"<p>Stops the component completely, potentially disengaging its power electronics controller(s).</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>Brings component to the cold-standby state</li> <li> <p>opens DC relays</p> </li> <li> <p>Battery: Checks if the power output is 0, then</p> </li> <li> <p>opens DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>opens relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>opens the DC relays.</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def StopComponent(self, request, context):\n    \"\"\"Stops the component completely, potentially disengaging its power\n    electronics controller(s).\n\n    Performs the following sequence actions for the following component\n    categories:\n\n    * Inverter:\n    * Brings component to the cold-standby state\n    * opens DC relays\n\n    * Battery: Checks if the power output is 0, then\n    * opens DC relays\n\n    * Relays:\n    * opens relays\n\n    * Precharge Modules:\n    * opens the DC relays.\n\n    If any of the checks mentioned above fails, then the method call returns an\n    error.\n\n    If any of the above mentioned actions for a given component has already\n    been performed, then this method call effectively skips that action.\n\n    If a feature required to perform an action is missing, then that action is\n    skipped.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridServicer.SubscribeComponentData","title":"<code>SubscribeComponentData(request, context)</code>","text":"<p>Returns a stream containing data from a component with a given ID.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def SubscribeComponentData(self, request, context):\n    \"\"\"Returns a stream containing data from a component with a given ID.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub","title":"<code>frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub</code>","text":"<p>             Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>class MicrogridStub(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.GetMicrogridMetadata = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/GetMicrogridMetadata',\n                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.MicrogridMetadata.FromString,\n                )\n        self.ListComponents = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/ListComponents',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentFilter.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentList.FromString,\n                )\n        self.ListConnections = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/ListConnections',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionFilter.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionList.FromString,\n                )\n        self.SubscribeComponentData = channel.unary_stream(\n                '/frequenz.api.microgrid.Microgrid/SubscribeComponentData',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentData.FromString,\n                )\n        self.AddComponentExclusionBounds = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/AddComponentExclusionBounds',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString,\n                )\n        self.AddComponentInclusionBounds = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/AddComponentInclusionBounds',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString,\n                )\n        self.SetComponentPowerActive = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/SetComponentPowerActive',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerActiveParam.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.SetComponentPowerReactive = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/SetComponentPowerReactive',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerReactiveParam.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.StartComponent = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/StartComponent',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.HotStandbyComponent = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/HotStandbyComponent',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.ColdStandbyComponent = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/ColdStandbyComponent',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.StopComponent = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/StopComponent',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.AckComponentError = channel.unary_unary(\n                '/frequenz.api.microgrid.Microgrid/AckComponentError',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.AckComponentError","title":"<code>AckComponentError: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/AckComponentError', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Acknowledges any recoverable error reported by the component, and brings it back to the stopped or cold-standby state.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.AddComponentExclusionBounds","title":"<code>AddComponentExclusionBounds: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.SetBoundsParam, google.protobuf.timestamp_pb2.Timestamp] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/AddComponentExclusionBounds', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString, response_deserializer=google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString)</code>  <code>instance-attribute</code>","text":"<p>Adds exclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given exclusion bounds will stay in effect.</p> <p>Exclusion bounds refer to the range of values that are disallowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraints <code>value &lt;= lower</code> OR <code>upper &lt;= value</code>.</p> <p>Exclusion bounds are a useful tool for enhancing the performance of a system. They can be used to restrict the acceptance of commands that fall below a certain threshold, which can help ensure the smooth functioning of the system. E.g., exclusion bounds can be set to limit the minimum charging power to a sufficiently high level, preventing a peak-shaver client from sending charge powers that are too low when a DC heater client is executing a charge pulse. This can significantly improve the overall performance of the DC heating mechanism.</p> <p>If multiple exclusion bounds have been provided bor a metric, then the aggregated lower and upper exclusion bounds are calculated as follows: lower: the minimum of all lower exclusion bounds upper: the maximum of all upper exclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_inclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>  inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\n               exclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and wil be rejected ==== vales here are allowed and will be accepted</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.AddComponentInclusionBounds","title":"<code>AddComponentInclusionBounds: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.SetBoundsParam, google.protobuf.timestamp_pb2.Timestamp] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/AddComponentInclusionBounds', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString, response_deserializer=google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString)</code>  <code>instance-attribute</code>","text":"<p>Adds inclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given inclusion bounds will stay in effect.</p> <p>Inclusion bounds refer to the range of values that are allowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraint <code>lower &lt;= value &lt;= upper</code>.</p> <p>If multiple inclusion bounds have been provided bor a metric, then the aggregated lower and upper inclusion bounds are calculated as follows: lower: the maximum of all lower inclusion bounds upper: the minimum of all upper inclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_exclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>  inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\n               exclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and wil be rejected ==== vales here are allowed and will be accepted</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.ColdStandbyComponent","title":"<code>ColdStandbyComponent: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/ColdStandbyComponent', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Sets the given component into a cold-standby state, from which it can return into an operational state within at most 2 minutes.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then</li> <li>sets power to 0, and</li> <li>opens AC relays</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call efffectively skips that action.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.GetMicrogridMetadata","title":"<code>GetMicrogridMetadata: grpc.UnaryUnaryMultiCallable[google.protobuf.empty_pb2.Empty, frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/GetMicrogridMetadata', request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.MicrogridMetadata.FromString)</code>  <code>instance-attribute</code>","text":"<p>/ Returns the microgrid metadata / The metadata consists of information that describes the overall / microgrid, as opposed to its components, / e.g., the microgrid ID, location.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.HotStandbyComponent","title":"<code>HotStandbyComponent: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/HotStandbyComponent', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Sets the given component into a hot-standby state, from which it can return into an operational state within at most 5 seconds.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then</li> <li>sets power to 0</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.ListComponents","title":"<code>ListComponents: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentFilter, frequenz.api.microgrid.microgrid_pb2.ComponentList] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/ListComponents', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentFilter.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentList.FromString)</code>  <code>instance-attribute</code>","text":"<p>List components in the local microgrid, optionally filtered by a given list of component IDs and component categories.</p> <p>If provided, the filters for component IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [  <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code>,  <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code> OR <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>.</p> <p>If a filter list is empty, then that filter is not applied.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.ListConnections","title":"<code>ListConnections: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ConnectionFilter, frequenz.api.microgrid.microgrid_pb2.ConnectionList] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/ListConnections', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionFilter.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionList.FromString)</code>  <code>instance-attribute</code>","text":"<p>Returns a list of the connections between components as <code>(start, end)</code> pairs of connection IDs, where the direction of individual connections is always away from the grid endpoint, i.e. aligned with the direction of positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p> <p>The request may be filtered by <code>start</code>/<code>end</code> component(s) of individual connections.  If provided, the <code>start</code> and <code>end</code> filters have an <code>AND</code> relationship between each other, meaning that they are applied serially, but an <code>OR</code> relationship with other elements in the same list. For example, if <code>start</code> = <code>[1, 2, 3]</code>, and <code>end</code> = <code>[4, 5, 6]</code>, then the result should have all the connections where * each <code>start</code> component ID is either <code>1</code>, <code>2</code>, OR <code>3</code>,  AND * each <code>end</code> component ID is either <code>4</code>, <code>5</code>, OR <code>6</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.SetComponentPowerActive","title":"<code>SetComponentPowerActive: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/SetComponentPowerActive', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerActiveParam.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Sets the active power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 W. E.g., an inverter may have a resolution of 88 W. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Sends the discharge command to the inverter, making it deliver  AC power.</li> </ul>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.SetComponentPowerReactive","title":"<code>SetComponentPowerReactive: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/SetComponentPowerReactive', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerReactiveParam.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Sets the reactive power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 VAr. E.g., an inverter may have a resolution of 88 VAr. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.StartComponent","title":"<code>StartComponent: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/StartComponent', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Starts the component, and brings it into a state where it is immediately operational.</p> <p>Performs the following sequence of actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>closes DC relays, if the feature is available</li> <li>closes AC relays</li> <li> <p>sets power output to 0</p> </li> <li> <p>Battery: Checks if DC relays are open, then</p> </li> <li> <p>closes DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>closes relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>starts the precharge process, and eventually closes the DC relays.</li> </ul> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.StopComponent","title":"<code>StopComponent: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.Microgrid/StopComponent', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Stops the component completely, potentially disengaging its power electronics controller(s).</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>Brings component to the cold-standby state</li> <li> <p>opens DC relays</p> </li> <li> <p>Battery: Checks if the power output is 0, then</p> </li> <li> <p>opens DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>opens relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>opens the DC relays.</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.SubscribeComponentData","title":"<code>SubscribeComponentData: grpc.UnaryStreamMultiCallable[frequenz.api.microgrid.microgrid_pb2.ComponentIdParam, frequenz.api.microgrid.microgrid_pb2.ComponentData] = channel.unary_stream('/frequenz.api.microgrid.Microgrid/SubscribeComponentData', request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentData.FromString)</code>  <code>instance-attribute</code>","text":"<p>Returns a stream containing data from a component with a given ID.</p>"},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/microgrid/microgrid_pb2_grpc/#frequenz.api.microgrid.microgrid_pb2_grpc.MicrogridStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> PARAMETER  DESCRIPTION <code>channel</code> <p>A grpc.Channel.</p> <p> TYPE: <code>Union[Channel, Channel]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/microgrid_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.GetMicrogridMetadata = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/GetMicrogridMetadata',\n            request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.MicrogridMetadata.FromString,\n            )\n    self.ListComponents = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/ListComponents',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentFilter.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentList.FromString,\n            )\n    self.ListConnections = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/ListConnections',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionFilter.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ConnectionList.FromString,\n            )\n    self.SubscribeComponentData = channel.unary_stream(\n            '/frequenz.api.microgrid.Microgrid/SubscribeComponentData',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentData.FromString,\n            )\n    self.AddComponentExclusionBounds = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/AddComponentExclusionBounds',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString,\n            )\n    self.AddComponentInclusionBounds = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/AddComponentInclusionBounds',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetBoundsParam.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_timestamp__pb2.Timestamp.FromString,\n            )\n    self.SetComponentPowerActive = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/SetComponentPowerActive',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerActiveParam.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.SetComponentPowerReactive = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/SetComponentPowerReactive',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.SetPowerReactiveParam.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.StartComponent = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/StartComponent',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.HotStandbyComponent = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/HotStandbyComponent',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.ColdStandbyComponent = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/ColdStandbyComponent',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.StopComponent = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/StopComponent',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.AckComponentError = channel.unary_unary(\n            '/frequenz.api.microgrid.Microgrid/AckComponentError',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_microgrid__pb2.ComponentIdParam.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/","title":"precharger_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2","title":"<code>frequenz.api.microgrid.precharger_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_ERROR","title":"<code>frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_ERROR: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The precharge module is in an error state.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_OFF","title":"<code>frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_OFF: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The precharge and the relsays are opened.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_ON","title":"<code>frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_ON: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The relays are on/closed, and the precharge circuit is open.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_PRECHARGING","title":"<code>frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_PRECHARGING: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>Precharging is in progress.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.precharger_pb2.COMPONENT_STATE_UNSPECIFIED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified state.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.ERROR_CODE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.precharger_pb2.ERROR_CODE_UNSPECIFIED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.ComponentState","title":"<code>frequenz.api.microgrid.precharger_pb2.ComponentState</code>","text":"<p>             Bases: <code>_ComponentState</code></p> <p>Enumerated meter states.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.Error","title":"<code>frequenz.api.microgrid.precharger_pb2.Error</code>","text":"<p>             Bases: <code>Message</code></p> <p>Error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.Error-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.Error.code","title":"<code>code: global___ErrorCode.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error code.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.Error.level","title":"<code>level: frequenz.api.microgrid.common_pb2.ErrorLevel.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error severity level.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.Error.msg","title":"<code>msg: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.ErrorCode","title":"<code>frequenz.api.microgrid.precharger_pb2.ErrorCode</code>","text":"<p>             Bases: <code>_ErrorCode</code></p> <p>Enumerated error codes.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.Precharger","title":"<code>frequenz.api.microgrid.precharger_pb2.Precharger</code>","text":"<p>             Bases: <code>Message</code></p> <p>Precharger details.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.Precharger-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.Precharger.errors","title":"<code>errors: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]</code>  <code>property</code>","text":"<p>A list of errors encountered the component. An empty list implies no error.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.Precharger.state","title":"<code>state: global___State</code>  <code>property</code>","text":"<p>The component's state.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.State","title":"<code>frequenz.api.microgrid.precharger_pb2.State</code>","text":"<p>             Bases: <code>Message</code></p> <p>State message.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.State-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2/#frequenz.api.microgrid.precharger_pb2.State.component_state","title":"<code>component_state: global___ComponentState.ValueType</code>  <code>instance-attribute</code>","text":"<p>The state of the overall component.</p>"},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2_grpc/","title":"precharger_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/precharger_pb2_grpc/#frequenz.api.microgrid.precharger_pb2_grpc","title":"<code>frequenz.api.microgrid.precharger_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/","title":"relay_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2","title":"<code>frequenz.api.microgrid.relay_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.COMPONENT_STATE_ERROR","title":"<code>frequenz.api.microgrid.relay_pb2.COMPONENT_STATE_ERROR: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The relay is in an error state.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.COMPONENT_STATE_OFF","title":"<code>frequenz.api.microgrid.relay_pb2.COMPONENT_STATE_OFF: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The relays are off/open.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.COMPONENT_STATE_ON","title":"<code>frequenz.api.microgrid.relay_pb2.COMPONENT_STATE_ON: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The relays are on/closed.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.COMPONENT_STATE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.relay_pb2.COMPONENT_STATE_UNSPECIFIED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified state.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.ERROR_CODE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.relay_pb2.ERROR_CODE_UNSPECIFIED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.ComponentState","title":"<code>frequenz.api.microgrid.relay_pb2.ComponentState</code>","text":"<p>             Bases: <code>_ComponentState</code></p> <p>Enumerated relay states.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.Error","title":"<code>frequenz.api.microgrid.relay_pb2.Error</code>","text":"<p>             Bases: <code>Message</code></p> <p>Error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.Error-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.Error.code","title":"<code>code: global___ErrorCode.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error code.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.Error.level","title":"<code>level: frequenz.api.microgrid.common_pb2.ErrorLevel.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error severity level.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.Error.msg","title":"<code>msg: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.ErrorCode","title":"<code>frequenz.api.microgrid.relay_pb2.ErrorCode</code>","text":"<p>             Bases: <code>_ErrorCode</code></p> <p>Enumerated error codes.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.Relay","title":"<code>frequenz.api.microgrid.relay_pb2.Relay</code>","text":"<p>             Bases: <code>Message</code></p> <p>Relay details.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.Relay-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.Relay.errors","title":"<code>errors: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]</code>  <code>property</code>","text":"<p>A list of errors encountered the component. An empty list implies no error.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.Relay.state","title":"<code>state: global___State</code>  <code>property</code>","text":"<p>The component's state.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.State","title":"<code>frequenz.api.microgrid.relay_pb2.State</code>","text":"<p>             Bases: <code>Message</code></p> <p>State message.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.State-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/relay_pb2/#frequenz.api.microgrid.relay_pb2.State.component_state","title":"<code>component_state: global___ComponentState.ValueType</code>  <code>instance-attribute</code>","text":"<p>The state of the overall component.</p>"},{"location":"python-reference/frequenz/api/microgrid/relay_pb2_grpc/","title":"relay_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/relay_pb2_grpc/#frequenz.api.microgrid.relay_pb2_grpc","title":"<code>frequenz.api.microgrid.relay_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/","title":"sensor_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2","title":"<code>frequenz.api.microgrid.sensor_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.COMPONENT_STATE_ERROR","title":"<code>frequenz.api.microgrid.sensor_pb2.COMPONENT_STATE_ERROR: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The sensor is in an error state.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.COMPONENT_STATE_OK","title":"<code>frequenz.api.microgrid.sensor_pb2.COMPONENT_STATE_OK: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>The sensor is behaving as expected.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.COMPONENT_STATE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.sensor_pb2.COMPONENT_STATE_UNSPECIFIED: ComponentState.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified state.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.ERROR_CODE_UNSPECIFIED","title":"<code>frequenz.api.microgrid.sensor_pb2.ERROR_CODE_UNSPECIFIED: ErrorCode.ValueType</code>  <code>module-attribute</code>","text":"<p>Unspecified.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.ComponentState","title":"<code>frequenz.api.microgrid.sensor_pb2.ComponentState</code>","text":"<p>             Bases: <code>_ComponentState</code></p> <p>Enumerated sensor states.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.5/x64/lib/python3.11/site-packages/frequenz/api/microgrid/sensor_pb2.py</code> <pre><code># @@protoc_insertion_point(module_scope)\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Data","title":"<code>frequenz.api.microgrid.sensor_pb2.Data</code>","text":"<p>             Bases: <code>Message</code></p> <p>Sensor data.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Data-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Data.sensor_data","title":"<code>sensor_data: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SensorData]</code>  <code>property</code>","text":"<p>An array of sensor data.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Error","title":"<code>frequenz.api.microgrid.sensor_pb2.Error</code>","text":"<p>             Bases: <code>Message</code></p> <p>Error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Error-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Error.code","title":"<code>code: global___ErrorCode.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error code.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Error.level","title":"<code>level: frequenz.api.microgrid.common_pb2.ErrorLevel.ValueType</code>  <code>instance-attribute</code>","text":"<p>The error severity level.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Error.msg","title":"<code>msg: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.ErrorCode","title":"<code>frequenz.api.microgrid.sensor_pb2.ErrorCode</code>","text":"<p>             Bases: <code>_ErrorCode</code></p> <p>Enumerated sensor error codes.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Metadata","title":"<code>frequenz.api.microgrid.sensor_pb2.Metadata</code>","text":"<p>             Bases: <code>Message</code></p> <p>The sensor metadata.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Metadata-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Metadata.type","title":"<code>type: frequenz.api.common.v1.sensors_pb2.SensorCategory.ValueType</code>  <code>instance-attribute</code>","text":"<p>The sensor type.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Properties","title":"<code>frequenz.api.microgrid.sensor_pb2.Properties</code>","text":"<p>             Bases: <code>Message</code></p> <p>Sensor properties.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Properties-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Properties.firmware_ver","title":"<code>firmware_ver: builtins.str</code>  <code>instance-attribute</code>","text":"<p>The firmware version of the component.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Sensor","title":"<code>frequenz.api.microgrid.sensor_pb2.Sensor</code>","text":"<p>             Bases: <code>Message</code></p> <p>Sensor details</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Sensor-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Sensor.data","title":"<code>data: global___Data</code>  <code>property</code>","text":"<p>Sensor data object.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Sensor.errors","title":"<code>errors: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]</code>  <code>property</code>","text":"<p>A list of errors encountered the component. An empty list implies no error.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Sensor.properties","title":"<code>properties: global___Properties</code>  <code>property</code>","text":"<p>The component properties</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.Sensor.state","title":"<code>state: global___State</code>  <code>property</code>","text":"<p>The sensor's state.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.SensorData","title":"<code>frequenz.api.microgrid.sensor_pb2.SensorData</code>","text":"<p>             Bases: <code>Message</code></p> <p>A value of a single metric.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.SensorData-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.SensorData.sensor_metric","title":"<code>sensor_metric: frequenz.api.common.v1.sensors_pb2.SensorMetric.ValueType</code>  <code>instance-attribute</code>","text":"<p>The metric name.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.SensorData.value","title":"<code>value: builtins.float</code>  <code>instance-attribute</code>","text":"<p>The metric value.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.State","title":"<code>frequenz.api.microgrid.sensor_pb2.State</code>","text":"<p>             Bases: <code>Message</code></p> <p>State message.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.State-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2/#frequenz.api.microgrid.sensor_pb2.State.component_state","title":"<code>component_state: global___ComponentState.ValueType</code>  <code>instance-attribute</code>","text":"<p>The state of the overall component.</p>"},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2_grpc/","title":"sensor_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/sensor_pb2_grpc/#frequenz.api.microgrid.sensor_pb2_grpc","title":"<code>frequenz.api.microgrid.sensor_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"}]}