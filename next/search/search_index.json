{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Microgrid API","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The Frequenz Microgrid API is an service for operating and monitoring electrical components and sensors within a microgrid. It offers various functionalities related to microgrid management, including metadata retrieval, component listing, setting power levels, and controlling the state of components. The API is structured around the concept of a microgrid, which is a localized energy system composed of various interconnected components and auxiliary sensors. Microgrids are typically connected to the main grid, but can also operate independently, in which case they are referred to as islanded microgrids.</p> <p>The API supports different categories of electrical components and sensors. The list of supported electrical component categories cam be found here. The list of supported sensor categories cam be found here. Note that each of these categories could have their own types, e.g., inverters could belong to the type \"battery\" or \"PV\". This information is stored in the metadata of each component and sensor, and is exposed by the API.</p> <p>The API streams data from the microgrid in real-time, allowing users to retrieve the status and performance of components and sensors. It also allows users to control the microgrid by setting power levels and controlling the state of components.</p>"},{"location":"#objective","title":"Objective","text":"<p>The objective of this API is to provide a standardized interface for monitoring and controlling components and sensors within a microgrid. The API is designed to be vendor-agnostic, allowing users to interact with components from various vendors using the same API.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Metadata Retrieval: The API allows users to retrieve metadata about the   microgrid, providing information about the microgrid's unique identifier (ID)   and geographical coordinates.</p> </li> <li> <p>Component Listing: Users can list components in the microgrid, optionally   filtered by component IDs and categories.</p> </li> <li> <p>Component Graphs: The API provides a way to list electrical connections   between components. Connections are represented as pairs of component IDs that   are directly connected. The connections can be visualized as a directed graph,   where the nodes are components, the edges are connections between components,   and the edge direction represents the direction of power flow in Passive Sign   Convention.</p> </li> <li> <p>Power Level Control: Users can set the active and reactive power levels of   components that support it.</p> </li> <li> <p>Component State Control: For components that support it, the API supports   starting, stopping, and transitioning components between these and the   standby states.</p> </li> <li> <p>Bounds Management: Users can set exclusion and inclusion bounds for   specific metrics of a component. These bounds define the acceptable and   unacceptable ranges of metric values. E.g., one could set the inclusion bounds   for a battery's DC power to be between -100kW and 100 kW, and the exclusion   bounds to be between -50kW and 50kW. This would allow the battery to operate   between -100kW and 100kW, but would prevent it from operating between -50kW   and 50kW.</p> </li> </ul>"},{"location":"#example-use-cases","title":"Example Use Cases:","text":"<p>This API is designed for use in microgrid management and control systems. It can be applied in various scenarios, including:</p> <ul> <li> <p>Microgrid Monitoring: Monitoring the status and performance of components   in a microgrid, allowing operators to ensure efficient energy distribution.</p> </li> <li> <p>Optimizing Energy Storage: Managing the charge and discharge power of   storage systems and generators, e.g., batteries, CHPs, etc., to optimize   energy storage and consumption within the microgrid.</p> </li> <li> <p>Flexibility Management: Managing the flexibility of components in the   microgrid, e.g., by controlling the state and power draw of electrical   components, to ensure that the microgrid can respond to changes in energy   demand.</p> </li> <li> <p>Performance Enhancements: Setting exclusion bounds for metrics to enhance   system performance and prevent extreme values in battery SoCs or power   output.</p> </li> </ul>"},{"location":"#target-audience","title":"Target Audience:","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge of any specific hardware implementation.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Microgrid API","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You need to make sure you have the <code>git submodules</code> updated:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"CONTRIBUTING/#running-protolint","title":"Running protolint","text":"<p>To make sure some common mistakes are avoided and to ensure a consistent style it is recommended to run <code>protolint</code>. After you installed <code>protolint</code>, just run:</p> <pre><code>protolint lint proto\n</code></pre>"},{"location":"CONTRIBUTING/#python-setup","title":"Python setup","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>This will also generate the Python files from the <code>proto/</code> files and leave them in <code>py/</code>, so you can inspect them.</p> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#upgrading-dependencies","title":"Upgrading dependencies","text":"<p>If you want to update the dependency <code>frequenz-api-common</code>, then you need to:</p> <ol> <li>Update the submodule <code>frequenz-api-common</code></li> <li>Update the version of the <code>frequenz-api-common</code> package in <code>pyproject.toml</code></li> </ol> <p>The version of <code>frequenz-api-common</code> used in both places mentioned above should be the same.</p> <p>Here is an example of upgrading the <code>frequenz-api-common</code> dependency to version <code>v0.2.0</code>: <pre><code>ver=\"0.2.0\"\n\ncd submodules/frequenz-api-common\ngit remote update\ngit checkout v${ver}\ncd -\n\nsed s/\"frequenz-api-common == [0-9]\\.[0-9]\\.[0-9]\"/\"frequenz-api-common == ${ver}\"/g -i pyproject.toml\n</code></pre></p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Protobuf API Reference</li> <li>Python API Reference</li> <li>Contributing</li> </ul>"},{"location":"protobuf-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>microgrid<ul> <li>v1<ul> <li>microgrid.proto</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/microgrid/v1/microgrid.proto</p> <ul> <li>AckComponentErrorRequest</li> <li>AddComponentExclusionBoundsRequest</li> <li>AddComponentExclusionBoundsResponse</li> <li>AddComponentInclusionBoundsRequest</li> <li>AddComponentInclusionBoundsResponse</li> <li>GetMicrogridMetadataResponse</li> <li>ListComponentsRequest</li> <li>ListComponentsResponse</li> <li>ListConnectionsRequest</li> <li>ListConnectionsResponse</li> <li>ListSensorRequest</li> <li>ListSensorsResponse</li> <li>PutComponentInStandbyRequest</li> <li>ReceiveComponentDataStreamRequest</li> <li>ReceiveComponentDataStreamResponse</li> <li>ReceiveSensorDataStreamRequest</li> <li>ReceiveSensorDataStreamResponse</li> <li>SetComponentPowerActiveRequest</li> <li>SetComponentPowerReactiveRequest</li> <li>StartComponentRequest</li> <li> <p>StopComponentRequest</p> </li> <li> <p>ComponentBoundsTargetMetric</p> </li> <li> <p>Microgrid</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#frequenzapimicrogridv1microgridproto","title":"frequenz/api/microgrid/v1/microgrid.proto","text":""},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#ackcomponenterrorrequest","title":"AckComponentErrorRequest","text":"<p>Request parameters for the RPC <code>AckComponentError</code>.</p> Field Type Label Description component_id uint64 The component ID to acknowledge the error for. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#addcomponentexclusionboundsrequest","title":"AddComponentExclusionBoundsRequest","text":"<p>Request parameters for the RPC <code>AddComponentExclusionBounds</code>.</p> Field Type Label Description component_id uint64 The ID of the target component. target_metric ComponentBoundsTargetMetric The target metric whose bounds have to be set. bounds frequenz.api.common.v1.metrics.Bounds The bounds for the target metric. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#addcomponentexclusionboundsresponse","title":"AddComponentExclusionBoundsResponse","text":"<p>Response message for the RPC <code>AddComponentExclusionBounds</code>.</p> Field Type Label Description ts google.protobuf.Timestamp The timestamp until which the given exclusion bounds will stay in effect. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#addcomponentinclusionboundsrequest","title":"AddComponentInclusionBoundsRequest","text":"<p>Request parameters for the RPC <code>AddComponentInclusionBounds</code>.</p> Field Type Label Description component_id uint64 The ID of the target component. target_metric ComponentBoundsTargetMetric The target metric whose bounds have to be set. bounds frequenz.api.common.v1.metrics.Bounds The bounds for the target metric. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#addcomponentinclusionboundsresponse","title":"AddComponentInclusionBoundsResponse","text":"<p>Response message for the RPC <code>AddComponentInclusionBounds</code>.</p> Field Type Label Description ts google.protobuf.Timestamp The timestamp until which the given inclusion bounds will stay in effect. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#getmicrogridmetadataresponse","title":"GetMicrogridMetadataResponse","text":"<p>Metadata that describes a microgrid.</p> Field Type Label Description microgrid frequenz.api.common.v1.microgrid.Microgrid The location of the microgrid, in geographical co-ordinates. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#listcomponentsrequest","title":"ListComponentsRequest","text":"<p>Request parameters for the RPC <code>ListComponents</code>. Contains filtering parameters for listing components.</p> Field Type Label Description component_ids uint64 repeated Return components that have the specified IDs only. categories frequenz.api.common.v1.microgrid.components.ComponentCategory repeated Return components that have the specified categories only. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#listcomponentsresponse","title":"ListComponentsResponse","text":"<p>A message containing a list of components. Used as the return type in the RPC <code>ListComponents</code>.</p> Field Type Label Description components frequenz.api.common.v1.microgrid.components.Component repeated <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#listconnectionsrequest","title":"ListConnectionsRequest","text":"<p>Request parameters for the RPC <code>ListConnections</code>. Contains filtering parameters for listing connections.</p> Field Type Label Description starts uint64 repeated Only return connections that start from the specified component ID(s): if empty, connections with any <code>start</code> will be returned ends uint64 repeated Only return connections that end at the specified component ID(s): if empty, connections with any <code>end</code> will be returned <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#listconnectionsresponse","title":"ListConnectionsResponse","text":"<p>Response message for the RPC <code>ListConnections</code>. Contains a list of connections.</p> Field Type Label Description connections frequenz.api.common.v1.microgrid.components.ComponentConnection repeated The list of connections. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#listsensorrequest","title":"ListSensorRequest","text":"<p>Request parameters for the RPC <code>ListSensors</code>. Contains filtering parameters for listing sensors.</p> Field Type Label Description sensor_ids uint64 repeated Return sensors that have the specified IDs only. categories frequenz.api.common.v1.microgrid.sensors.SensorCategory repeated Return sensors that have the specified categories only. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#listsensorsresponse","title":"ListSensorsResponse","text":"<p>Response message for the RPC <code>ListSensors</code>. A message containing a list of sensors.</p> Field Type Label Description sensors frequenz.api.common.v1.microgrid.sensors.Sensor repeated <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#putcomponentinstandbyrequest","title":"PutComponentInStandbyRequest","text":"<p>Request parameters for the RPC <code>PutComponentInStandby</code>.</p> Field Type Label Description component_id uint64 The component ID to set to standby. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#receivecomponentdatastreamrequest","title":"ReceiveComponentDataStreamRequest","text":"<p>Request parameters for the RPC <code>ReceiveComponentDataStream</code>.</p> Field Type Label Description component_id uint64 The component ID to subscribe to. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#receivecomponentdatastreamresponse","title":"ReceiveComponentDataStreamResponse","text":"<p>A data sample from a component in the microgrid. Components belonging to all categories and types can be represented using this message.</p> Field Type Label Description data frequenz.api.common.v1.microgrid.components.ComponentData <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#receivesensordatastreamrequest","title":"ReceiveSensorDataStreamRequest","text":"<p>Request parameters for the RPC <code>ReceiveSensorDataStream</code>.</p> Field Type Label Description sensor_id uint64 The sensor ID to subscribe to. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#receivesensordatastreamresponse","title":"ReceiveSensorDataStreamResponse","text":"<p>A data sample from a sensor in the microgrid.</p> Field Type Label Description data frequenz.api.common.v1.microgrid.sensors.SensorData The sensor data. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#setcomponentpoweractiverequest","title":"SetComponentPowerActiveRequest","text":"<p>Request parameters for the RPC <code>SetComponentPowerActive</code>.</p> Field Type Label Description component_id uint64 The ID of the component to set the output active power of. power float The output active power level, in watts. -ve values are for discharging, and +ve values are for charging. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#setcomponentpowerreactiverequest","title":"SetComponentPowerReactiveRequest","text":"<p>Request parameters for the RPC <code>SetComponentPowerReactive</code>.</p> Field Type Label Description component_id uint64 The ID of the component to set the output reactive power of. power float The output reactive power level, in VAr. -ve values are for inductive (lagging) power , and +ve values are for capacitive (leading) power. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#startcomponentrequest","title":"StartComponentRequest","text":"<p>Request parameters for the RPC <code>StartComponent</code>.</p> Field Type Label Description component_id uint64 The component ID to start. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#stopcomponentrequest","title":"StopComponentRequest","text":"<p>Request parameters for the RPC <code>StopComponent</code>.</p> Field Type Label Description component_id uint64 The component ID to stop. <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#componentboundstargetmetric","title":"ComponentBoundsTargetMetric","text":"<p>An enumerated list of metrics whose bounds can be set using the RPCs <code>AddComponentExclusionBounds</code> and <code>AddComponentInclusionBounds</code>.</p> Name Number Description COMPONENT_BOUNDS_TARGET_METRIC_UNSPECIFIED 0 COMPONENT_BOUNDS_TARGET_METRIC_POWER_ACTIVE 1 COMPONENT_BOUNDS_TARGET_METRIC_CURRENT 2 COMPONENT_BOUNDS_TARGET_METRIC_CURRENT_PHASE_1 3 COMPONENT_BOUNDS_TARGET_METRIC_CURRENT_PHASE_2 4 COMPONENT_BOUNDS_TARGET_METRIC_CURRENT_PHASE_3 5 COMPONENT_BOUNDS_TARGET_METRIC_POWER_REACTIVE 6 <p></p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#microgrid","title":"Microgrid","text":"<p>The Frequenz Microgrid API</p> Method Name Request Type Response Type Description GetMicrogridMetadata .google.protobuf.Empty GetMicrogridMetadataResponse Returns the microgrid metadata The metadata consists of information that describes the overall microgrid, as opposed to its electrical components or sensors, e.g., the microgrid ID, location. ListComponents ListComponentsRequest ListComponentsResponse List electrical components in the local microgrid, optionally filtered by a given list of component IDs and component categories. <p>Electrical components are a part of a microgrid's electrical infrastructure are can be connected to each other to form an electrical circuit, which can then be represented as a graph.</p> <p>If provided, the filters for component IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [ <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code>, <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code> OR <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>.</p> <p>If a filter list is empty, then that filter is not applied. | | ListSensors | ListSensorRequest | ListSensorsResponse | Returns a list of sensors in the local microgrid, optionally filtered by a given list of sensor IDs and sensor categories.</p> <p>Sensors measure physical metrics in the microgrid's surroundings, and are not classified as electrical components.</p> <p>If provided, the filters for sensor IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [ <code>SensorCategory::SENSOR_CATEGORY_THERMOMETER</code>, <code>SensorCategory::SENSOR_CATEGORY_HYGROMETER</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>SensorCategory::SENSOR_CATEGORY_THERMOMETER</code> OR <code>SensorCategory::SENSOR_CATEGORY_HYGROMETER</code>.</p> <p>If a filter list is empty, then that filter is not applied. | | ListConnections | ListConnectionsRequest | ListConnectionsResponse | Electrical components are a part of a microgrid's electrical infrastructure are can be connected to each other to form an electrical circuit, which can then be represented as a graph.</p> <p>This RPC return a list of the connections between two components, denoted by <code>(start, end)</code>. The direction of a connection is always away from the grid endpoint, i.e. aligned with the direction of positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p> <p>The request may be filtered by <code>start</code>/<code>end</code> component(s) of individual connections. If provided, the <code>start</code> and <code>end</code> filters have an <code>AND</code> relationship between each other, meaning that they are applied serially, but an <code>OR</code> relationship with other elements in the same list. For example, if <code>start</code> = <code>[1, 2, 3]</code>, and <code>end</code> = <code>[4, 5, 6]</code>, then the result should have all the connections where * each <code>start</code> component ID is either <code>1</code>, <code>2</code>, OR <code>3</code>, AND * each <code>end</code> component ID is either <code>4</code>, <code>5</code>, OR <code>6</code>. | | ReceiveComponentDataStream | ReceiveComponentDataStreamRequest | ReceiveComponentDataStreamResponse stream | Returns a stream containing data from a component with a given ID. | | ReceiveSensorDataStream | ReceiveSensorDataStreamRequest | ReceiveSensorDataStreamResponse stream | Returns a stream containing data from a sensor with a given ID. | | AddComponentExclusionBounds | AddComponentExclusionBoundsRequest | AddComponentExclusionBoundsResponse | Adds exclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given exclusion bounds will stay in effect.</p> <p>Exclusion bounds refer to the range of values that are disallowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraints <code>value &amp;lt;= lower</code> OR <code>upper &amp;lt;= value</code>.</p> <p>Exclusion bounds are a useful tool for enhancing the performance of a system. They can be used to restrict the acceptance of commands that fall below a certain threshold, which can help ensure the smooth functioning of the system. E.g., exclusion bounds can be set to limit the minimum charging power to a sufficiently high level, preventing a peak-shaver client from sending charge powers that are too low when a DC heater client is executing a charge pulse. This can significantly improve the overall performance of the DC heating mechanism.</p> <p>If multiple exclusion bounds have been provided bor a metric, then the aggregated lower and upper exclusion bounds are calculated as follows: lower: the minimum of all lower exclusion bounds upper: the maximum of all upper exclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_inclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <code>inclusion.lower inclusion.upper &amp;lt;-------|============|------------------|============|---------&amp;gt; exclusion.lower exclusion.upper</code> ---- values here are disallowed and will be rejected ==== vales here are allowed and will be accepted | | AddComponentInclusionBounds | AddComponentInclusionBoundsRequest | AddComponentInclusionBoundsResponse | Adds inclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given inclusion bounds will stay in effect.</p> <p>Inclusion bounds refer to the range of values that are allowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraint <code>lower &amp;lt;= value &amp;lt;= upper</code>.</p> <p>If multiple inclusion bounds have been provided bor a metric, then the aggregated lower and upper inclusion bounds are calculated as follows: lower: the maximum of all lower inclusion bounds upper: the minimum of all upper inclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_exclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <code>inclusion.lower inclusion.upper &amp;lt;-------|============|------------------|============|---------&amp;gt; exclusion.lower exclusion.upper</code> ---- values here are disallowed and will be rejected ==== vales here are allowed and will be accepted | | SetComponentPowerActive | SetComponentPowerActiveRequest | .google.protobuf.Empty | Sets the active power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 W. E.g., an inverter may have a resolution of 88 W. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Sends the discharge command to the inverter, making it deliver AC power. | | SetComponentPowerReactive | SetComponentPowerReactiveRequest | .google.protobuf.Empty | Sets the reactive power output of a component with a given ID, provided the component supports it.</li> </ul> <p>Note that the target component may have a resolution of more than 1 VAr. E.g., an inverter may have a resolution of 88 VAr. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution. | | StartComponent | StartComponentRequest | .google.protobuf.Empty | Starts the component, and brings it into a state where it is immediately operational.</p> <p>Performs the following sequence of actions for the following component categories:</p> <ul> <li> <p>Inverter: * closes DC relays, if the feature is available * closes AC relays * sets power output to 0</p> </li> <li> <p>Battery: Checks if DC relays are open, then * closes DC relays</p> </li> <li> <p>Relays: * closes relays</p> </li> <li> <p>Precharge Modules: * starts the precharge process, and eventually closes the DC relays.</p> </li> </ul> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped. | | PutComponentInStandby | PutComponentInStandbyRequest | .google.protobuf.Empty | Sets the given component into a standby state, from which it can take a few minutes to return to an operational state. A transition to an operational state can be triggered by calling the <code>StartComponent</code> RPC, or the <code>SetComponentPowerActive</code> RPC.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then * sets power to 0, and * opens AC relays</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call efffectively skips that action. | | StopComponent | StopComponentRequest | .google.protobuf.Empty | Stops the component completely, potentially disengaging its power electronics controller(s).</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li> <p>Inverter: * Brings component to the cold-standby state * opens DC relays</p> </li> <li> <p>Battery: Checks if the power output is 0, then * opens DC relays</p> </li> <li> <p>Relays: * opens relays</p> </li> <li> <p>Precharge Modules: * opens the DC relays.</p> </li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped. | | AckComponentError | AckComponentErrorRequest | .google.protobuf.Empty | Acknowledges any recoverable error reported by the component, and brings it back to the stopped or cold-standby state. |</p>"},{"location":"protobuf-reference/frequenz/api/microgrid/v1/microgrid/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"python-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>microgrid<ul> <li>v1<ul> <li>microgrid_pb2</li> <li>microgrid_pb2_grpc</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"python-reference/frequenz/api/microgrid/","title":"Index","text":""},{"location":"python-reference/frequenz/api/microgrid/#frequenz.api.microgrid","title":"<code>frequenz.api.microgrid</code>","text":"<p>Frequenz gRPC API for monitoring and control of microgrids.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/","title":"Index","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/#frequenz.api.microgrid.v1","title":"<code>frequenz.api.microgrid.v1</code>","text":"<p>Frequenz gRPC API for monitoring and control of microgrids.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/","title":"microgrid_pb2","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AckComponentErrorRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.AckComponentErrorRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>AckComponentError</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AckComponentErrorRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AckComponentErrorRequest.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The component ID to acknowledge the error for.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>AddComponentExclusionBounds</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsRequest.bounds","title":"<code>bounds: frequenz.api.common.v1.metrics.bounds_pb2.Bounds</code>  <code>property</code>","text":"<p>The bounds for the target metric.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsRequest.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The ID of the target component.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsRequest.target_metric","title":"<code>target_metric: global___ComponentBoundsTargetMetric.ValueType</code>  <code>instance-attribute</code>","text":"<p>The target metric whose bounds have to be set.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsResponse","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsResponse</code>","text":"<p>             Bases: <code>Message</code></p> <p>Response message for the RPC <code>AddComponentExclusionBounds</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsResponse.ts","title":"<code>ts: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The timestamp until which the given exclusion bounds will stay in effect.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>AddComponentInclusionBounds</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsRequest.bounds","title":"<code>bounds: frequenz.api.common.v1.metrics.bounds_pb2.Bounds</code>  <code>property</code>","text":"<p>The bounds for the target metric.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsRequest.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The ID of the target component.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsRequest.target_metric","title":"<code>target_metric: global___ComponentBoundsTargetMetric.ValueType</code>  <code>instance-attribute</code>","text":"<p>The target metric whose bounds have to be set.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsResponse","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsResponse</code>","text":"<p>             Bases: <code>Message</code></p> <p>Response message for the RPC <code>AddComponentInclusionBounds</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsResponse.ts","title":"<code>ts: google.protobuf.timestamp_pb2.Timestamp</code>  <code>property</code>","text":"<p>The timestamp until which the given inclusion bounds will stay in effect.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ComponentBoundsTargetMetric","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ComponentBoundsTargetMetric</code>","text":"<p>             Bases: <code>_ComponentBoundsTargetMetric</code></p> <p>An enumerated list of metrics whose bounds can be set using the RPCs <code>AddComponentExclusionBounds</code> and <code>AddComponentInclusionBounds</code>.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2.py</code> <pre><code>_MICROGRID.methods_by_name['SetComponentPowerReactive']._options = None\n_MICROGRID.methods_by_name['SetComponentPowerReactive']._serialized_options = b'\\202\\323\\344\\223\\0028\\0226/v1/components/{component_id}/setPowerReactive/{power}'\n_MICROGRID.methods_by_name['StartComponent']._options = None\n_MICROGRID.methods_by_name['StartComponent']._serialized_options = b'\\202\\323\\344\\223\\002\\033\\022\\031/v1/components/{id}/start'\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse</code>","text":"<p>             Bases: <code>Message</code></p> <p>Metadata that describes a microgrid.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2.py</code> <pre><code>_globals['_LISTCOMPONENTSREQUEST']._serialized_start=597\n_globals['_LISTCOMPONENTSREQUEST']._serialized_end=727\n_globals['_LISTCOMPONENTSRESPONSE']._serialized_start=729\n_globals['_LISTCOMPONENTSRESPONSE']._serialized_end=829\n_globals['_LISTSENSORREQUEST']._serialized_start=831\n_globals['_LISTSENSORREQUEST']._serialized_end=948\n_globals['_LISTSENSORSRESPONSE']._serialized_start=950\n_globals['_LISTSENSORSRESPONSE']._serialized_end=1038\n_globals['_LISTCONNECTIONSREQUEST']._serialized_start=1040\n_globals['_LISTCONNECTIONSREQUEST']._serialized_end=1094\n_globals['_LISTCONNECTIONSRESPONSE']._serialized_start=1096\n_globals['_LISTCONNECTIONSRESPONSE']._serialized_end=1208\n_globals['_RECEIVECOMPONENTDATASTREAMREQUEST']._serialized_start=1210\n_globals['_RECEIVECOMPONENTDATASTREAMREQUEST']._serialized_end=1267\n_globals['_RECEIVECOMPONENTDATASTREAMRESPONSE']._serialized_start=1269\n_globals['_RECEIVECOMPONENTDATASTREAMRESPONSE']._serialized_end=1379\n_globals['_RECEIVESENSORDATASTREAMREQUEST']._serialized_start=1381\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse.microgrid","title":"<code>microgrid: frequenz.api.common.v1.microgrid.microgrid_pb2.Microgrid</code>  <code>property</code>","text":"<p>The location of the microgrid, in geographical co-ordinates.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>ListComponents</code>. Contains filtering parameters for listing components.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2.py</code> <pre><code>  _globals['_ADDCOMPONENTEXCLUSIONBOUNDSREQUEST']._serialized_start=1538\n  _globals['_ADDCOMPONENTEXCLUSIONBOUNDSREQUEST']._serialized_end=1731\n  _globals['_ADDCOMPONENTEXCLUSIONBOUNDSRESPONSE']._serialized_start=1733\n  _globals['_ADDCOMPONENTEXCLUSIONBOUNDSRESPONSE']._serialized_end=1810\n  _globals['_ADDCOMPONENTINCLUSIONBOUNDSREQUEST']._serialized_start=1813\n  _globals['_ADDCOMPONENTINCLUSIONBOUNDSREQUEST']._serialized_end=2006\n  _globals['_ADDCOMPONENTINCLUSIONBOUNDSRESPONSE']._serialized_start=2008\n  _globals['_ADDCOMPONENTINCLUSIONBOUNDSRESPONSE']._serialized_end=2085\n  _globals['_SETCOMPONENTPOWERACTIVEREQUEST']._serialized_start=2087\n  _globals['_SETCOMPONENTPOWERACTIVEREQUEST']._serialized_end=2156\n  _globals['_SETCOMPONENTPOWERREACTIVEREQUEST']._serialized_start=2158\n  _globals['_SETCOMPONENTPOWERREACTIVEREQUEST']._serialized_end=2229\n  _globals['_STARTCOMPONENTREQUEST']._serialized_start=2231\n  _globals['_STARTCOMPONENTREQUEST']._serialized_end=2276\n  _globals['_PUTCOMPONENTINSTANDBYREQUEST']._serialized_start=2278\n  _globals['_PUTCOMPONENTINSTANDBYREQUEST']._serialized_end=2330\n  _globals['_STOPCOMPONENTREQUEST']._serialized_start=2332\n  _globals['_STOPCOMPONENTREQUEST']._serialized_end=2376\n  _globals['_ACKCOMPONENTERRORREQUEST']._serialized_start=2378\n  _globals['_ACKCOMPONENTERRORREQUEST']._serialized_end=2426\n  _globals['_MICROGRID']._serialized_start=2809\n  _globals['_MICROGRID']._serialized_end=4944\n# @@protoc_insertion_point(module_scope)\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest.categories","title":"<code>categories: google.protobuf.internal.containers.RepeatedScalarFieldContainer[frequenz.api.common.v1.microgrid.components.components_pb2.ComponentCategory.ValueType]</code>  <code>property</code>","text":"<p>Return components that have the specified categories only.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest.component_ids","title":"<code>component_ids: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>Return components that have the specified IDs only.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsResponse","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsResponse</code>","text":"<p>             Bases: <code>Message</code></p> <p>A message containing a list of components. Used as the return type in the RPC <code>ListComponents</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>ListConnections</code>. Contains filtering parameters for listing connections.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest.ends","title":"<code>ends: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>Only return connections that end at the specified component ID(s): if empty, connections with any <code>end</code> will be returned</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest.starts","title":"<code>starts: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>Only return connections that start from the specified component ID(s): if empty, connections with any <code>start</code> will be returned</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse</code>","text":"<p>             Bases: <code>Message</code></p> <p>Response message for the RPC <code>ListConnections</code>. Contains a list of connections.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse.connections","title":"<code>connections: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.microgrid.components.components_pb2.ComponentConnection]</code>  <code>property</code>","text":"<p>The list of connections.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>ListSensors</code>. Contains filtering parameters for listing sensors.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest.categories","title":"<code>categories: google.protobuf.internal.containers.RepeatedScalarFieldContainer[frequenz.api.common.v1.microgrid.sensors.sensors_pb2.SensorCategory.ValueType]</code>  <code>property</code>","text":"<p>Return sensors that have the specified categories only.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest.sensor_ids","title":"<code>sensor_ids: google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]</code>  <code>property</code>","text":"<p>Return sensors that have the specified IDs only.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ListSensorsResponse","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ListSensorsResponse</code>","text":"<p>             Bases: <code>Message</code></p> <p>Response message for the RPC <code>ListSensors</code>. A message containing a list of sensors.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.PutComponentInStandbyRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.PutComponentInStandbyRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>PutComponentInStandby</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.PutComponentInStandbyRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.PutComponentInStandbyRequest.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The component ID to set to standby.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>ReceiveComponentDataStream</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamRequest.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The component ID to subscribe to.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamResponse","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamResponse</code>","text":"<p>             Bases: <code>Message</code></p> <p>A data sample from a component in the microgrid. Components belonging to all categories and types can be represented using this message.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>ReceiveSensorDataStream</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamRequest.sensor_id","title":"<code>sensor_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The sensor ID to subscribe to.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse</code>","text":"<p>             Bases: <code>Message</code></p> <p>A data sample from a sensor in the microgrid.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse.data","title":"<code>data: frequenz.api.common.v1.microgrid.sensors.sensors_pb2.SensorData</code>  <code>property</code>","text":"<p>The sensor data.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>SetComponentPowerActive</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The ID of the component to set the output active power of.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest.power","title":"<code>power: builtins.float</code>  <code>instance-attribute</code>","text":"<p>The output active power level, in watts. -ve values are for discharging, and +ve values are for charging.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>SetComponentPowerReactive</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The ID of the component to set the output reactive power of.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest.power","title":"<code>power: builtins.float</code>  <code>instance-attribute</code>","text":"<p>The output reactive power level, in VAr. -ve values are for inductive (lagging) power , and +ve values are for  capacitive (leading) power.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.StartComponentRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.StartComponentRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>StartComponent</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.StartComponentRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.StartComponentRequest.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The component ID to start.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.StopComponentRequest","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2.StopComponentRequest</code>","text":"<p>             Bases: <code>Message</code></p> <p>Request parameters for the RPC <code>StopComponent</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.StopComponentRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2/#frequenz.api.microgrid.v1.microgrid_pb2.StopComponentRequest.component_id","title":"<code>component_id: builtins.int</code>  <code>instance-attribute</code>","text":"<p>The component ID to stop.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/","title":"microgrid_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2_grpc</code>","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.Microgrid","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2_grpc.Microgrid</code>","text":"<p>             Bases: <code>object</code></p> <p>The Frequenz Microgrid API</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>class Microgrid(object):\n    \"\"\"The Frequenz Microgrid API\n    \"\"\"\n\n    @staticmethod\n    def GetMicrogridMetadata(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/GetMicrogridMetadata',\n            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.GetMicrogridMetadataResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListComponents(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/ListComponents',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListSensors(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/ListSensors',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListConnections(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/ListConnections',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ReceiveComponentDataStream(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(request, target, '/frequenz.api.microgrid.v1.Microgrid/ReceiveComponentDataStream',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ReceiveSensorDataStream(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(request, target, '/frequenz.api.microgrid.v1.Microgrid/ReceiveSensorDataStream',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AddComponentExclusionBounds(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/AddComponentExclusionBounds',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AddComponentInclusionBounds(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/AddComponentInclusionBounds',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def SetComponentPowerActive(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerActive',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveRequest.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def SetComponentPowerReactive(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerReactive',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveRequest.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def StartComponent(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/StartComponent',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StartComponentRequest.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def PutComponentInStandby(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/PutComponentInStandby',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.PutComponentInStandbyRequest.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def StopComponent(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/StopComponent',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StopComponentRequest.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AckComponentError(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/AckComponentError',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AckComponentErrorRequest.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub</code>","text":"<p>The Frequenz Microgrid API</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>        * Precharge Modules:\n        * starts the precharge process, and eventually closes the DC relays.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call effectively skips that action.\n\n        If a feature required to perform an action is missing, then that action is\n        skipped.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def PutComponentInStandby(self, request, context):\n        \"\"\"Sets the given component into a standby state, from which it can take a\n        few minutes to return to an operational state. A transition to an\n        operational state can be triggered by calling the `StartComponent` RPC, or\n        the `SetComponentPowerActive` RPC.\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter: Checks if AC and DC relays are closed, then\n        * sets power to 0, and\n        * opens AC relays\n\n        If any of the checks mentioned above fails, then the method call returns an\n        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call efffectively skips that action.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def StopComponent(self, request, context):\n        \"\"\"Stops the component completely, potentially disengaging its power\n        electronics controller(s).\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter:\n        * Brings component to the cold-standby state\n        * opens DC relays\n\n        * Battery: Checks if the power output is 0, then\n        * opens DC relays\n\n        * Relays:\n        * opens relays\n\n        * Precharge Modules:\n        * opens the DC relays.\n\n        If any of the checks mentioned above fails, then the method call returns an\n        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call effectively skips that action.\n\n        If a feature required to perform an action is missing, then that action is\n        skipped.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def AckComponentError(self, request, context):\n        \"\"\"Acknowledges any recoverable error reported by the component, and brings it\n        back to the stopped or cold-standby state.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n\ndef add_MicrogridServicer_to_server(servicer, server):\n    rpc_method_handlers = {\n            'GetMicrogridMetadata': grpc.unary_unary_rpc_method_handler(\n                    servicer.GetMicrogridMetadata,\n                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.GetMicrogridMetadataResponse.SerializeToString,\n            ),\n            'ListComponents': grpc.unary_unary_rpc_method_handler(\n                    servicer.ListComponents,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsRequest.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsResponse.SerializeToString,\n            ),\n            'ListSensors': grpc.unary_unary_rpc_method_handler(\n                    servicer.ListSensors,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorRequest.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorsResponse.SerializeToString,\n            ),\n            'ListConnections': grpc.unary_unary_rpc_method_handler(\n                    servicer.ListConnections,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsRequest.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsResponse.SerializeToString,\n            ),\n            'ReceiveComponentDataStream': grpc.unary_stream_rpc_method_handler(\n                    servicer.ReceiveComponentDataStream,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamRequest.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamResponse.SerializeToString,\n            ),\n            'ReceiveSensorDataStream': grpc.unary_stream_rpc_method_handler(\n                    servicer.ReceiveSensorDataStream,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamRequest.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamResponse.SerializeToString,\n            ),\n            'AddComponentExclusionBounds': grpc.unary_unary_rpc_method_handler(\n                    servicer.AddComponentExclusionBounds,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsRequest.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsResponse.SerializeToString,\n            ),\n            'AddComponentInclusionBounds': grpc.unary_unary_rpc_method_handler(\n                    servicer.AddComponentInclusionBounds,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsRequest.FromString,\n                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsResponse.SerializeToString,\n            ),\n            'SetComponentPowerActive': grpc.unary_unary_rpc_method_handler(\n                    servicer.SetComponentPowerActive,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveRequest.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'SetComponentPowerReactive': grpc.unary_unary_rpc_method_handler(\n                    servicer.SetComponentPowerReactive,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveRequest.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'StartComponent': grpc.unary_unary_rpc_method_handler(\n                    servicer.StartComponent,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StartComponentRequest.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'PutComponentInStandby': grpc.unary_unary_rpc_method_handler(\n                    servicer.PutComponentInStandby,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.PutComponentInStandbyRequest.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'StopComponent': grpc.unary_unary_rpc_method_handler(\n                    servicer.StopComponent,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StopComponentRequest.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n            'AckComponentError': grpc.unary_unary_rpc_method_handler(\n                    servicer.AckComponentError,\n                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AckComponentErrorRequest.FromString,\n                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            ),\n    }\n    generic_handler = grpc.method_handlers_generic_handler(\n            'frequenz.api.microgrid.v1.Microgrid', rpc_method_handlers)\n    server.add_generic_rpc_handlers((generic_handler,))\n\n\n # This class is part of an EXPERIMENTAL API.\nclass Microgrid(object):\n    \"\"\"The Frequenz Microgrid API\n    \"\"\"\n\n    @staticmethod\n    def GetMicrogridMetadata(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/GetMicrogridMetadata',\n            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.GetMicrogridMetadataResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListComponents(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/ListComponents',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListSensors(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/ListSensors',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListConnections(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/ListConnections',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ReceiveComponentDataStream(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(request, target, '/frequenz.api.microgrid.v1.Microgrid/ReceiveComponentDataStream',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ReceiveSensorDataStream(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(request, target, '/frequenz.api.microgrid.v1.Microgrid/ReceiveSensorDataStream',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AddComponentExclusionBounds(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/AddComponentExclusionBounds',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def AddComponentInclusionBounds(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/AddComponentInclusionBounds',\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsRequest.SerializeToString,\n            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def SetComponentPowerActive(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.AckComponentError","title":"<code>AckComponentError: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.AckComponentErrorRequest, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Acknowledges any recoverable error reported by the component, and brings it back to the stopped or cold-standby state.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.AddComponentExclusionBounds","title":"<code>AddComponentExclusionBounds: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsRequest, frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsResponse]</code>  <code>instance-attribute</code>","text":"<p>Adds exclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given exclusion bounds will stay in effect.</p> <p>Exclusion bounds refer to the range of values that are disallowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraints <code>value &lt;= lower</code> OR <code>upper &lt;= value</code>.</p> <p>Exclusion bounds are a useful tool for enhancing the performance of a system. They can be used to restrict the acceptance of commands that fall below a certain threshold, which can help ensure the smooth functioning of the system. E.g., exclusion bounds can be set to limit the minimum charging power to a sufficiently high level, preventing a peak-shaver client from sending charge powers that are too low when a DC heater client is executing a charge pulse. This can significantly improve the overall performance of the DC heating mechanism.</p> <p>If multiple exclusion bounds have been provided bor a metric, then the aggregated lower and upper exclusion bounds are calculated as follows: lower: the minimum of all lower exclusion bounds upper: the maximum of all upper exclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_inclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>  inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\n               exclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and will be rejected ==== vales here are allowed and will be accepted</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.AddComponentInclusionBounds","title":"<code>AddComponentInclusionBounds: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsRequest, frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsResponse]</code>  <code>instance-attribute</code>","text":"<p>Adds inclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given inclusion bounds will stay in effect.</p> <p>Inclusion bounds refer to the range of values that are allowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraint <code>lower &lt;= value &lt;= upper</code>.</p> <p>If multiple inclusion bounds have been provided bor a metric, then the aggregated lower and upper inclusion bounds are calculated as follows: lower: the maximum of all lower inclusion bounds upper: the minimum of all upper inclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_exclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>  inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\n               exclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and will be rejected ==== vales here are allowed and will be accepted</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.GetMicrogridMetadata","title":"<code>GetMicrogridMetadata: grpc.aio.UnaryUnaryMultiCallable[google.protobuf.empty_pb2.Empty, frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse]</code>  <code>instance-attribute</code>","text":"<p>Returns the microgrid metadata The metadata consists of information that describes the overall microgrid, as opposed to its electrical components or sensors, e.g., the microgrid ID, location.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.ListComponents","title":"<code>ListComponents: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest, frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsResponse]</code>  <code>instance-attribute</code>","text":"<p>List electrical components in the local microgrid, optionally filtered by a given list of component IDs and component categories.</p> <p>Electrical components are a part of a microgrid's electrical infrastructure are can be connected to each other to form an electrical circuit, which can then be represented as a graph.</p> <p>If provided, the filters for component IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [  <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code>,  <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code> OR <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>.</p> <p>If a filter list is empty, then that filter is not applied.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.ListConnections","title":"<code>ListConnections: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest, frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse]</code>  <code>instance-attribute</code>","text":"<p>Electrical components are a part of a microgrid's electrical infrastructure are can be connected to each other to form an electrical circuit, which can then be represented as a graph.</p> <p>This RPC return a list of the connections between two components, denoted by <code>(start, end)</code>. The direction of a connection is always away from the grid endpoint, i.e. aligned with the direction of positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p> <p>The request may be filtered by <code>start</code>/<code>end</code> component(s) of individual connections.  If provided, the <code>start</code> and <code>end</code> filters have an <code>AND</code> relationship between each other, meaning that they are applied serially, but an <code>OR</code> relationship with other elements in the same list. For example, if <code>start</code> = <code>[1, 2, 3]</code>, and <code>end</code> = <code>[4, 5, 6]</code>, then the result should have all the connections where * each <code>start</code> component ID is either <code>1</code>, <code>2</code>, OR <code>3</code>,  AND * each <code>end</code> component ID is either <code>4</code>, <code>5</code>, OR <code>6</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.ListSensors","title":"<code>ListSensors: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest, frequenz.api.microgrid.v1.microgrid_pb2.ListSensorsResponse]</code>  <code>instance-attribute</code>","text":"<p>Returns a list of sensors in the local microgrid, optionally filtered by a given list of sensor IDs and sensor categories.</p> <p>Sensors measure physical metrics in the microgrid's surroundings, and are not classified as electrical components.</p> <p>If provided, the filters for sensor IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [  <code>SensorCategory::SENSOR_CATEGORY_THERMOMETER</code>,  <code>SensorCategory::SENSOR_CATEGORY_HYGROMETER</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>SensorCategory::SENSOR_CATEGORY_THERMOMETER</code> OR <code>SensorCategory::SENSOR_CATEGORY_HYGROMETER</code>.</p> <p>If a filter list is empty, then that filter is not applied.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.PutComponentInStandby","title":"<code>PutComponentInStandby: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.PutComponentInStandbyRequest, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Sets the given component into a standby state, from which it can take a few minutes to return to an operational state. A transition to an operational state can be triggered by calling the <code>StartComponent</code> RPC, or the <code>SetComponentPowerActive</code> RPC.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then</li> <li>sets power to 0, and</li> <li>opens AC relays</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call efffectively skips that action.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.ReceiveComponentDataStream","title":"<code>ReceiveComponentDataStream: grpc.aio.UnaryStreamMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamRequest, frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamResponse]</code>  <code>instance-attribute</code>","text":"<p>Returns a stream containing data from a component with a given ID.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.ReceiveSensorDataStream","title":"<code>ReceiveSensorDataStream: grpc.aio.UnaryStreamMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamRequest, frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse]</code>  <code>instance-attribute</code>","text":"<p>Returns a stream containing data from a sensor with a given ID.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.SetComponentPowerActive","title":"<code>SetComponentPowerActive: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Sets the active power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 W. E.g., an inverter may have a resolution of 88 W. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Sends the discharge command to the inverter, making it deliver  AC power.</li> </ul>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.SetComponentPowerReactive","title":"<code>SetComponentPowerReactive: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Sets the reactive power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 VAr. E.g., an inverter may have a resolution of 88 VAr. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.StartComponent","title":"<code>StartComponent: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.StartComponentRequest, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Starts the component, and brings it into a state where it is immediately operational.</p> <p>Performs the following sequence of actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>closes DC relays, if the feature is available</li> <li>closes AC relays</li> <li> <p>sets power output to 0</p> </li> <li> <p>Battery: Checks if DC relays are open, then</p> </li> <li> <p>closes DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>closes relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>starts the precharge process, and eventually closes the DC relays.</li> </ul> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridAsyncStub.StopComponent","title":"<code>StopComponent: grpc.aio.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.StopComponentRequest, google.protobuf.empty_pb2.Empty]</code>  <code>instance-attribute</code>","text":"<p>Stops the component completely, potentially disengaging its power electronics controller(s).</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>Brings component to the cold-standby state</li> <li> <p>opens DC relays</p> </li> <li> <p>Battery: Checks if the power output is 0, then</p> </li> <li> <p>opens DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>opens relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>opens the DC relays.</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer</code>","text":"<p>             Bases: <code>object</code></p> <p>The Frequenz Microgrid API</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>class MicrogridServicer(object):\n    \"\"\"The Frequenz Microgrid API\n    \"\"\"\n\n    def GetMicrogridMetadata(self, request, context):\n        \"\"\"Returns the microgrid metadata\n        The metadata consists of information that describes the overall\n        microgrid, as opposed to its electrical components or sensors,\n        e.g., the microgrid ID, location.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ListComponents(self, request, context):\n        \"\"\"List electrical components in the local microgrid, optionally filtered by a\n        given list of component IDs and component categories.\n\n        Electrical components are a part of a microgrid's electrical infrastructure\n        are can be connected to each other to form an electrical circuit, which can\n        then be represented as a graph.\n\n        If provided, the filters for component IDs and categories have an `AND`\n        relationship with one another, meaning that they are applied serially,\n        but the elements within a single filter list have an `OR` relationship with\n        each other.\n        E.g., if `ids` = [1, 2, 3], and `categories` = [\n        `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,\n        `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],\n        then the results will consist of elements that\n        have the IDs 1, OR 2, OR 3,\n        AND\n        are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR\n        `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.\n\n        If a filter list is empty, then that filter is not applied.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ListSensors(self, request, context):\n        \"\"\"Returns a list of sensors in the local microgrid, optionally filtered by a\n        given list of sensor IDs and sensor categories.\n\n        Sensors measure physical metrics in the microgrid's surroundings, and are\n        not classified as electrical components.\n\n        If provided, the filters for sensor IDs and categories have an `AND`\n        relationship with one another, meaning that they are applied serially,\n        but the elements within a single filter list have an `OR` relationship with\n        each other.\n        E.g., if `ids` = [1, 2, 3], and `categories` = [\n        `SensorCategory::SENSOR_CATEGORY_THERMOMETER`,\n        `SensorCategory::SENSOR_CATEGORY_HYGROMETER`],\n        then the results will consist of elements that\n        have the IDs 1, OR 2, OR 3,\n        AND\n        are of the categories `SensorCategory::SENSOR_CATEGORY_THERMOMETER` OR\n        `SensorCategory::SENSOR_CATEGORY_HYGROMETER`.\n\n        If a filter list is empty, then that filter is not applied.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ListConnections(self, request, context):\n        \"\"\"Electrical components are a part of a microgrid's electrical infrastructure\n        are can be connected to each other to form an electrical circuit, which can\n        then be represented as a graph.\n\n        This RPC return a list of the connections between two components, denoted\n        by `(start, end)`. The direction of a connection is always away from the\n        grid endpoint, i.e. aligned with the direction of positive current\n        according to the passive sign convention:\n        https://en.wikipedia.org/wiki/Passive_sign_convention\n\n        The request may be filtered by `start`/`end` component(s) of individual\n        connections.  If provided, the `start` and `end` filters have an `AND`\n        relationship between each other, meaning that they are applied serially,\n        but an `OR` relationship with other elements in the same list.\n        For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the\n        result should have all the connections where\n        * each `start` component ID is either `1`, `2`, OR `3`,\n        AND\n        * each `end` component ID is either `4`, `5`, OR `6`.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ReceiveComponentDataStream(self, request, context):\n        \"\"\"Returns a stream containing data from a component with a given ID.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ReceiveSensorDataStream(self, request, context):\n        \"\"\"Returns a stream containing data from a sensor with a given ID.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def AddComponentExclusionBounds(self, request, context):\n        \"\"\"Adds exclusion bounds for a given metric of a given component, and returns\n        the UTC timestamp until which the given exclusion bounds will stay in\n        effect.\n\n        Exclusion bounds refer to the range of values that are disallowed for the\n        metric. If these bounds for a metric are [`lower`, `upper`], then this\n        metric's `value` needs to comply with the constraints\n        `value &lt;= lower` OR `upper &lt;= value`.\n\n        Exclusion bounds are a useful tool for enhancing the performance of a\n        system. They can be used to restrict the acceptance of commands that fall\n        below a certain threshold, which can help ensure the smooth functioning of\n        the system.\n        E.g., exclusion bounds can be set to limit the minimum charging power to a\n        sufficiently high level, preventing a peak-shaver client from sending\n        charge powers that are too low when a DC heater client is executing a\n        charge pulse. This can significantly improve the overall performance of the\n        DC heating mechanism.\n\n\n        If multiple exclusion bounds have been provided bor a metric, then the\n        aggregated lower and upper exclusion bounds are calculated as follows:\n        lower: the minimum of all lower exclusion bounds\n        upper: the maximum of all upper exclusion bounds\n\n        It is important to note that these bounds work together with\n        `system_inclusion_bounds`.\n\n        E.g., for the system to accept a charge command,\n        clients need to request power values within the bounds\n        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.\n        This means that clients can only request charge commands with values that\n        are within the `system_inclusion_bounds`, but not within\n        `system_exclusion_bounds`.\n        Similarly, for the system to accept a discharge command,\n        clients need to request power values within the bounds\n        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.\n\n        The following diagram illustrates the relationship between the bounds.\n        ```\n        inclusion.lower                              inclusion.upper\n        &lt;-------|============|------------------|============|---------&gt;\n        exclusion.lower    exclusion.upper\n        ```\n        ---- values here are disallowed and will be rejected\n        ==== vales here are allowed and will be accepted\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def AddComponentInclusionBounds(self, request, context):\n        \"\"\"Adds inclusion bounds for a given metric of a given component, and returns\n        the UTC timestamp until which the given inclusion bounds will stay in\n        effect.\n\n        Inclusion bounds refer to the range of values that are allowed for the\n        metric. If these bounds for a metric are [`lower`, `upper`], then this\n        metric's `value` needs to comply with the constraint\n        `lower &lt;= value &lt;= upper`.\n\n        If multiple inclusion bounds have been provided bor a metric, then the\n        aggregated lower and upper inclusion bounds are calculated as follows:\n        lower: the maximum of all lower inclusion bounds\n        upper: the minimum of all upper inclusion bounds\n\n        It is important to note that these bounds work together with\n        `system_exclusion_bounds`.\n\n        E.g., for the system to accept a charge command,\n        clients need to request power values within the bounds\n        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.\n        This means that clients can only request charge commands with values that\n        are within the `system_inclusion_bounds`, but not within\n        `system_exclusion_bounds`.\n        Similarly, for the system to accept a discharge command,\n        clients need to request power values within the bounds\n        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.\n\n        The following diagram illustrates the relationship between the bounds.\n        ```\n        inclusion.lower                              inclusion.upper\n        &lt;-------|============|------------------|============|---------&gt;\n        exclusion.lower    exclusion.upper\n        ```\n        ---- values here are disallowed and will be rejected\n        ==== vales here are allowed and will be accepted\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def SetComponentPowerActive(self, request, context):\n        \"\"\"Sets the active power output of a component with a given ID, provided the\n        component supports it.\n\n        Note that the target component may have a resolution of more than 1 W.\n        E.g., an inverter may have a resolution of 88 W.\n        In such cases, the magnitude of power will be floored to the nearest\n        multiple of the resolution.\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter: Sends the discharge command to the inverter, making it deliver\n        AC power.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def SetComponentPowerReactive(self, request, context):\n        \"\"\"Sets the reactive power output of a component with a given ID, provided the\n        component supports it.\n\n        Note that the target component may have a resolution of more than 1 VAr.\n        E.g., an inverter may have a resolution of 88 VAr.\n        In such cases, the magnitude of power will be floored to the nearest\n        multiple of the resolution.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def StartComponent(self, request, context):\n        \"\"\"Starts the component, and brings it into a state where it is immediately\n        operational.\n\n        Performs the following sequence of actions for the following component\n        categories:\n\n        * Inverter:\n        * closes DC relays, if the feature is available\n        * closes AC relays\n        * sets power output to 0\n\n        * Battery: Checks if DC relays are open, then\n        * closes DC relays\n\n        * Relays:\n        * closes relays\n\n        * Precharge Modules:\n        * starts the precharge process, and eventually closes the DC relays.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call effectively skips that action.\n\n        If a feature required to perform an action is missing, then that action is\n        skipped.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def PutComponentInStandby(self, request, context):\n        \"\"\"Sets the given component into a standby state, from which it can take a\n        few minutes to return to an operational state. A transition to an\n        operational state can be triggered by calling the `StartComponent` RPC, or\n        the `SetComponentPowerActive` RPC.\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter: Checks if AC and DC relays are closed, then\n        * sets power to 0, and\n        * opens AC relays\n\n        If any of the checks mentioned above fails, then the method call returns an\n        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call efffectively skips that action.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def StopComponent(self, request, context):\n        \"\"\"Stops the component completely, potentially disengaging its power\n        electronics controller(s).\n\n        Performs the following sequence actions for the following component\n        categories:\n\n        * Inverter:\n        * Brings component to the cold-standby state\n        * opens DC relays\n\n        * Battery: Checks if the power output is 0, then\n        * opens DC relays\n\n        * Relays:\n        * opens relays\n\n        * Precharge Modules:\n        * opens the DC relays.\n\n        If any of the checks mentioned above fails, then the method call returns an\n        error.\n\n        If any of the above mentioned actions for a given component has already\n        been performed, then this method call effectively skips that action.\n\n        If a feature required to perform an action is missing, then that action is\n        skipped.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def AckComponentError(self, request, context):\n        \"\"\"Acknowledges any recoverable error reported by the component, and brings it\n        back to the stopped or cold-standby state.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.AckComponentError","title":"<code>AckComponentError(request, context)</code>","text":"<p>Acknowledges any recoverable error reported by the component, and brings it back to the stopped or cold-standby state.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def AckComponentError(self, request, context):\n    \"\"\"Acknowledges any recoverable error reported by the component, and brings it\n    back to the stopped or cold-standby state.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.AddComponentExclusionBounds","title":"<code>AddComponentExclusionBounds(request, context)</code>","text":"<p>Adds exclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given exclusion bounds will stay in effect.</p> <p>Exclusion bounds refer to the range of values that are disallowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraints <code>value &lt;= lower</code> OR <code>upper &lt;= value</code>.</p> <p>Exclusion bounds are a useful tool for enhancing the performance of a system. They can be used to restrict the acceptance of commands that fall below a certain threshold, which can help ensure the smooth functioning of the system. E.g., exclusion bounds can be set to limit the minimum charging power to a sufficiently high level, preventing a peak-shaver client from sending charge powers that are too low when a DC heater client is executing a charge pulse. This can significantly improve the overall performance of the DC heating mechanism.</p> <p>If multiple exclusion bounds have been provided bor a metric, then the aggregated lower and upper exclusion bounds are calculated as follows: lower: the minimum of all lower exclusion bounds upper: the maximum of all upper exclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_inclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\nexclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and will be rejected ==== vales here are allowed and will be accepted</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def AddComponentExclusionBounds(self, request, context):\n    \"\"\"Adds exclusion bounds for a given metric of a given component, and returns\n    the UTC timestamp until which the given exclusion bounds will stay in\n    effect.\n\n    Exclusion bounds refer to the range of values that are disallowed for the\n    metric. If these bounds for a metric are [`lower`, `upper`], then this\n    metric's `value` needs to comply with the constraints\n    `value &lt;= lower` OR `upper &lt;= value`.\n\n    Exclusion bounds are a useful tool for enhancing the performance of a\n    system. They can be used to restrict the acceptance of commands that fall\n    below a certain threshold, which can help ensure the smooth functioning of\n    the system.\n    E.g., exclusion bounds can be set to limit the minimum charging power to a\n    sufficiently high level, preventing a peak-shaver client from sending\n    charge powers that are too low when a DC heater client is executing a\n    charge pulse. This can significantly improve the overall performance of the\n    DC heating mechanism.\n\n\n    If multiple exclusion bounds have been provided bor a metric, then the\n    aggregated lower and upper exclusion bounds are calculated as follows:\n    lower: the minimum of all lower exclusion bounds\n    upper: the maximum of all upper exclusion bounds\n\n    It is important to note that these bounds work together with\n    `system_inclusion_bounds`.\n\n    E.g., for the system to accept a charge command,\n    clients need to request power values within the bounds\n    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.\n    This means that clients can only request charge commands with values that\n    are within the `system_inclusion_bounds`, but not within\n    `system_exclusion_bounds`.\n    Similarly, for the system to accept a discharge command,\n    clients need to request power values within the bounds\n    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.\n\n    The following diagram illustrates the relationship between the bounds.\n    ```\n    inclusion.lower                              inclusion.upper\n    &lt;-------|============|------------------|============|---------&gt;\n    exclusion.lower    exclusion.upper\n    ```\n    ---- values here are disallowed and will be rejected\n    ==== vales here are allowed and will be accepted\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.AddComponentInclusionBounds","title":"<code>AddComponentInclusionBounds(request, context)</code>","text":"<p>Adds inclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given inclusion bounds will stay in effect.</p> <p>Inclusion bounds refer to the range of values that are allowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraint <code>lower &lt;= value &lt;= upper</code>.</p> <p>If multiple inclusion bounds have been provided bor a metric, then the aggregated lower and upper inclusion bounds are calculated as follows: lower: the maximum of all lower inclusion bounds upper: the minimum of all upper inclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_exclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\nexclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and will be rejected ==== vales here are allowed and will be accepted</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def AddComponentInclusionBounds(self, request, context):\n    \"\"\"Adds inclusion bounds for a given metric of a given component, and returns\n    the UTC timestamp until which the given inclusion bounds will stay in\n    effect.\n\n    Inclusion bounds refer to the range of values that are allowed for the\n    metric. If these bounds for a metric are [`lower`, `upper`], then this\n    metric's `value` needs to comply with the constraint\n    `lower &lt;= value &lt;= upper`.\n\n    If multiple inclusion bounds have been provided bor a metric, then the\n    aggregated lower and upper inclusion bounds are calculated as follows:\n    lower: the maximum of all lower inclusion bounds\n    upper: the minimum of all upper inclusion bounds\n\n    It is important to note that these bounds work together with\n    `system_exclusion_bounds`.\n\n    E.g., for the system to accept a charge command,\n    clients need to request power values within the bounds\n    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.\n    This means that clients can only request charge commands with values that\n    are within the `system_inclusion_bounds`, but not within\n    `system_exclusion_bounds`.\n    Similarly, for the system to accept a discharge command,\n    clients need to request power values within the bounds\n    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.\n\n    The following diagram illustrates the relationship between the bounds.\n    ```\n    inclusion.lower                              inclusion.upper\n    &lt;-------|============|------------------|============|---------&gt;\n    exclusion.lower    exclusion.upper\n    ```\n    ---- values here are disallowed and will be rejected\n    ==== vales here are allowed and will be accepted\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.GetMicrogridMetadata","title":"<code>GetMicrogridMetadata(request, context)</code>","text":"<p>Returns the microgrid metadata The metadata consists of information that describes the overall microgrid, as opposed to its electrical components or sensors, e.g., the microgrid ID, location.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def GetMicrogridMetadata(self, request, context):\n    \"\"\"Returns the microgrid metadata\n    The metadata consists of information that describes the overall\n    microgrid, as opposed to its electrical components or sensors,\n    e.g., the microgrid ID, location.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.ListComponents","title":"<code>ListComponents(request, context)</code>","text":"<p>List electrical components in the local microgrid, optionally filtered by a given list of component IDs and component categories.</p> <p>Electrical components are a part of a microgrid's electrical infrastructure are can be connected to each other to form an electrical circuit, which can then be represented as a graph.</p> <p>If provided, the filters for component IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [ <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code>, <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code> OR <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>.</p> <p>If a filter list is empty, then that filter is not applied.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def ListComponents(self, request, context):\n    \"\"\"List electrical components in the local microgrid, optionally filtered by a\n    given list of component IDs and component categories.\n\n    Electrical components are a part of a microgrid's electrical infrastructure\n    are can be connected to each other to form an electrical circuit, which can\n    then be represented as a graph.\n\n    If provided, the filters for component IDs and categories have an `AND`\n    relationship with one another, meaning that they are applied serially,\n    but the elements within a single filter list have an `OR` relationship with\n    each other.\n    E.g., if `ids` = [1, 2, 3], and `categories` = [\n    `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,\n    `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],\n    then the results will consist of elements that\n    have the IDs 1, OR 2, OR 3,\n    AND\n    are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR\n    `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.\n\n    If a filter list is empty, then that filter is not applied.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.ListConnections","title":"<code>ListConnections(request, context)</code>","text":"<p>Electrical components are a part of a microgrid's electrical infrastructure are can be connected to each other to form an electrical circuit, which can then be represented as a graph.</p> <p>This RPC return a list of the connections between two components, denoted by <code>(start, end)</code>. The direction of a connection is always away from the grid endpoint, i.e. aligned with the direction of positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p> <p>The request may be filtered by <code>start</code>/<code>end</code> component(s) of individual connections.  If provided, the <code>start</code> and <code>end</code> filters have an <code>AND</code> relationship between each other, meaning that they are applied serially, but an <code>OR</code> relationship with other elements in the same list. For example, if <code>start</code> = <code>[1, 2, 3]</code>, and <code>end</code> = <code>[4, 5, 6]</code>, then the result should have all the connections where * each <code>start</code> component ID is either <code>1</code>, <code>2</code>, OR <code>3</code>, AND * each <code>end</code> component ID is either <code>4</code>, <code>5</code>, OR <code>6</code>.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def ListConnections(self, request, context):\n    \"\"\"Electrical components are a part of a microgrid's electrical infrastructure\n    are can be connected to each other to form an electrical circuit, which can\n    then be represented as a graph.\n\n    This RPC return a list of the connections between two components, denoted\n    by `(start, end)`. The direction of a connection is always away from the\n    grid endpoint, i.e. aligned with the direction of positive current\n    according to the passive sign convention:\n    https://en.wikipedia.org/wiki/Passive_sign_convention\n\n    The request may be filtered by `start`/`end` component(s) of individual\n    connections.  If provided, the `start` and `end` filters have an `AND`\n    relationship between each other, meaning that they are applied serially,\n    but an `OR` relationship with other elements in the same list.\n    For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the\n    result should have all the connections where\n    * each `start` component ID is either `1`, `2`, OR `3`,\n    AND\n    * each `end` component ID is either `4`, `5`, OR `6`.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.ListSensors","title":"<code>ListSensors(request, context)</code>","text":"<p>Returns a list of sensors in the local microgrid, optionally filtered by a given list of sensor IDs and sensor categories.</p> <p>Sensors measure physical metrics in the microgrid's surroundings, and are not classified as electrical components.</p> <p>If provided, the filters for sensor IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [ <code>SensorCategory::SENSOR_CATEGORY_THERMOMETER</code>, <code>SensorCategory::SENSOR_CATEGORY_HYGROMETER</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>SensorCategory::SENSOR_CATEGORY_THERMOMETER</code> OR <code>SensorCategory::SENSOR_CATEGORY_HYGROMETER</code>.</p> <p>If a filter list is empty, then that filter is not applied.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def ListSensors(self, request, context):\n    \"\"\"Returns a list of sensors in the local microgrid, optionally filtered by a\n    given list of sensor IDs and sensor categories.\n\n    Sensors measure physical metrics in the microgrid's surroundings, and are\n    not classified as electrical components.\n\n    If provided, the filters for sensor IDs and categories have an `AND`\n    relationship with one another, meaning that they are applied serially,\n    but the elements within a single filter list have an `OR` relationship with\n    each other.\n    E.g., if `ids` = [1, 2, 3], and `categories` = [\n    `SensorCategory::SENSOR_CATEGORY_THERMOMETER`,\n    `SensorCategory::SENSOR_CATEGORY_HYGROMETER`],\n    then the results will consist of elements that\n    have the IDs 1, OR 2, OR 3,\n    AND\n    are of the categories `SensorCategory::SENSOR_CATEGORY_THERMOMETER` OR\n    `SensorCategory::SENSOR_CATEGORY_HYGROMETER`.\n\n    If a filter list is empty, then that filter is not applied.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.PutComponentInStandby","title":"<code>PutComponentInStandby(request, context)</code>","text":"<p>Sets the given component into a standby state, from which it can take a few minutes to return to an operational state. A transition to an operational state can be triggered by calling the <code>StartComponent</code> RPC, or the <code>SetComponentPowerActive</code> RPC.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then</li> <li>sets power to 0, and</li> <li>opens AC relays</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call efffectively skips that action.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def PutComponentInStandby(self, request, context):\n    \"\"\"Sets the given component into a standby state, from which it can take a\n    few minutes to return to an operational state. A transition to an\n    operational state can be triggered by calling the `StartComponent` RPC, or\n    the `SetComponentPowerActive` RPC.\n\n    Performs the following sequence actions for the following component\n    categories:\n\n    * Inverter: Checks if AC and DC relays are closed, then\n    * sets power to 0, and\n    * opens AC relays\n\n    If any of the checks mentioned above fails, then the method call returns an\n    error.\n\n    If any of the above mentioned actions for a given component has already\n    been performed, then this method call efffectively skips that action.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.ReceiveComponentDataStream","title":"<code>ReceiveComponentDataStream(request, context)</code>","text":"<p>Returns a stream containing data from a component with a given ID.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def ReceiveComponentDataStream(self, request, context):\n    \"\"\"Returns a stream containing data from a component with a given ID.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.ReceiveSensorDataStream","title":"<code>ReceiveSensorDataStream(request, context)</code>","text":"<p>Returns a stream containing data from a sensor with a given ID.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def ReceiveSensorDataStream(self, request, context):\n    \"\"\"Returns a stream containing data from a sensor with a given ID.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.SetComponentPowerActive","title":"<code>SetComponentPowerActive(request, context)</code>","text":"<p>Sets the active power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 W. E.g., an inverter may have a resolution of 88 W. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Sends the discharge command to the inverter, making it deliver AC power.</li> </ul> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def SetComponentPowerActive(self, request, context):\n    \"\"\"Sets the active power output of a component with a given ID, provided the\n    component supports it.\n\n    Note that the target component may have a resolution of more than 1 W.\n    E.g., an inverter may have a resolution of 88 W.\n    In such cases, the magnitude of power will be floored to the nearest\n    multiple of the resolution.\n\n    Performs the following sequence actions for the following component\n    categories:\n\n    * Inverter: Sends the discharge command to the inverter, making it deliver\n    AC power.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.SetComponentPowerReactive","title":"<code>SetComponentPowerReactive(request, context)</code>","text":"<p>Sets the reactive power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 VAr. E.g., an inverter may have a resolution of 88 VAr. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def SetComponentPowerReactive(self, request, context):\n    \"\"\"Sets the reactive power output of a component with a given ID, provided the\n    component supports it.\n\n    Note that the target component may have a resolution of more than 1 VAr.\n    E.g., an inverter may have a resolution of 88 VAr.\n    In such cases, the magnitude of power will be floored to the nearest\n    multiple of the resolution.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.StartComponent","title":"<code>StartComponent(request, context)</code>","text":"<p>Starts the component, and brings it into a state where it is immediately operational.</p> <p>Performs the following sequence of actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>closes DC relays, if the feature is available</li> <li>closes AC relays</li> <li> <p>sets power output to 0</p> </li> <li> <p>Battery: Checks if DC relays are open, then</p> </li> <li> <p>closes DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>closes relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>starts the precharge process, and eventually closes the DC relays.</li> </ul> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def StartComponent(self, request, context):\n    \"\"\"Starts the component, and brings it into a state where it is immediately\n    operational.\n\n    Performs the following sequence of actions for the following component\n    categories:\n\n    * Inverter:\n    * closes DC relays, if the feature is available\n    * closes AC relays\n    * sets power output to 0\n\n    * Battery: Checks if DC relays are open, then\n    * closes DC relays\n\n    * Relays:\n    * closes relays\n\n    * Precharge Modules:\n    * starts the precharge process, and eventually closes the DC relays.\n\n    If any of the above mentioned actions for a given component has already\n    been performed, then this method call effectively skips that action.\n\n    If a feature required to perform an action is missing, then that action is\n    skipped.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridServicer.StopComponent","title":"<code>StopComponent(request, context)</code>","text":"<p>Stops the component completely, potentially disengaging its power electronics controller(s).</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>Brings component to the cold-standby state</li> <li> <p>opens DC relays</p> </li> <li> <p>Battery: Checks if the power output is 0, then</p> </li> <li> <p>opens DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>opens relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>opens the DC relays.</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def StopComponent(self, request, context):\n    \"\"\"Stops the component completely, potentially disengaging its power\n    electronics controller(s).\n\n    Performs the following sequence actions for the following component\n    categories:\n\n    * Inverter:\n    * Brings component to the cold-standby state\n    * opens DC relays\n\n    * Battery: Checks if the power output is 0, then\n    * opens DC relays\n\n    * Relays:\n    * opens relays\n\n    * Precharge Modules:\n    * opens the DC relays.\n\n    If any of the checks mentioned above fails, then the method call returns an\n    error.\n\n    If any of the above mentioned actions for a given component has already\n    been performed, then this method call effectively skips that action.\n\n    If a feature required to perform an action is missing, then that action is\n    skipped.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub","title":"<code>frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub</code>","text":"<p>             Bases: <code>object</code></p> <p>The Frequenz Microgrid API</p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>class MicrogridStub(object):\n    \"\"\"The Frequenz Microgrid API\n    \"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.GetMicrogridMetadata = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/GetMicrogridMetadata',\n                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.GetMicrogridMetadataResponse.FromString,\n                )\n        self.ListComponents = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/ListComponents',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsResponse.FromString,\n                )\n        self.ListSensors = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/ListSensors',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorsResponse.FromString,\n                )\n        self.ListConnections = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/ListConnections',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsResponse.FromString,\n                )\n        self.ReceiveComponentDataStream = channel.unary_stream(\n                '/frequenz.api.microgrid.v1.Microgrid/ReceiveComponentDataStream',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamResponse.FromString,\n                )\n        self.ReceiveSensorDataStream = channel.unary_stream(\n                '/frequenz.api.microgrid.v1.Microgrid/ReceiveSensorDataStream',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamResponse.FromString,\n                )\n        self.AddComponentExclusionBounds = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/AddComponentExclusionBounds',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsResponse.FromString,\n                )\n        self.AddComponentInclusionBounds = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/AddComponentInclusionBounds',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsResponse.FromString,\n                )\n        self.SetComponentPowerActive = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerActive',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.SetComponentPowerReactive = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerReactive',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.StartComponent = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/StartComponent',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StartComponentRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.PutComponentInStandby = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/PutComponentInStandby',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.PutComponentInStandbyRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.StopComponent = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/StopComponent',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StopComponentRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n        self.AckComponentError = channel.unary_unary(\n                '/frequenz.api.microgrid.v1.Microgrid/AckComponentError',\n                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AckComponentErrorRequest.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                )\n</code></pre>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.AckComponentError","title":"<code>AckComponentError: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.AckComponentErrorRequest, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/AckComponentError', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AckComponentErrorRequest.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Acknowledges any recoverable error reported by the component, and brings it back to the stopped or cold-standby state.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.AddComponentExclusionBounds","title":"<code>AddComponentExclusionBounds: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsRequest, frequenz.api.microgrid.v1.microgrid_pb2.AddComponentExclusionBoundsResponse] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/AddComponentExclusionBounds', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsRequest.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsResponse.FromString)</code>  <code>instance-attribute</code>","text":"<p>Adds exclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given exclusion bounds will stay in effect.</p> <p>Exclusion bounds refer to the range of values that are disallowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraints <code>value &lt;= lower</code> OR <code>upper &lt;= value</code>.</p> <p>Exclusion bounds are a useful tool for enhancing the performance of a system. They can be used to restrict the acceptance of commands that fall below a certain threshold, which can help ensure the smooth functioning of the system. E.g., exclusion bounds can be set to limit the minimum charging power to a sufficiently high level, preventing a peak-shaver client from sending charge powers that are too low when a DC heater client is executing a charge pulse. This can significantly improve the overall performance of the DC heating mechanism.</p> <p>If multiple exclusion bounds have been provided bor a metric, then the aggregated lower and upper exclusion bounds are calculated as follows: lower: the minimum of all lower exclusion bounds upper: the maximum of all upper exclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_inclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>  inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\n               exclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and will be rejected ==== vales here are allowed and will be accepted</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.AddComponentInclusionBounds","title":"<code>AddComponentInclusionBounds: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsRequest, frequenz.api.microgrid.v1.microgrid_pb2.AddComponentInclusionBoundsResponse] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/AddComponentInclusionBounds', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsRequest.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsResponse.FromString)</code>  <code>instance-attribute</code>","text":"<p>Adds inclusion bounds for a given metric of a given component, and returns the UTC timestamp until which the given inclusion bounds will stay in effect.</p> <p>Inclusion bounds refer to the range of values that are allowed for the metric. If these bounds for a metric are [<code>lower</code>, <code>upper</code>], then this metric's <code>value</code> needs to comply with the constraint <code>lower &lt;= value &lt;= upper</code>.</p> <p>If multiple inclusion bounds have been provided bor a metric, then the aggregated lower and upper inclusion bounds are calculated as follows: lower: the maximum of all lower inclusion bounds upper: the minimum of all upper inclusion bounds</p> <p>It is important to note that these bounds work together with <code>system_exclusion_bounds</code>.</p> <p>E.g., for the system to accept a charge command, clients need to request power values within the bounds <code>[system_inclusion_bounds.lower, system_exclusion_bounds.lower]</code>. This means that clients can only request charge commands with values that are within the <code>system_inclusion_bounds</code>, but not within <code>system_exclusion_bounds</code>. Similarly, for the system to accept a discharge command, clients need to request power values within the bounds <code>[system_exclusion_bounds.upper, system_inclusion_bounds.upper]</code>.</p> <p>The following diagram illustrates the relationship between the bounds. <pre><code>  inclusion.lower                              inclusion.upper\n&lt;-------|============|------------------|============|---------&gt;\n               exclusion.lower    exclusion.upper\n</code></pre> ---- values here are disallowed and will be rejected ==== vales here are allowed and will be accepted</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.GetMicrogridMetadata","title":"<code>GetMicrogridMetadata: grpc.UnaryUnaryMultiCallable[google.protobuf.empty_pb2.Empty, frequenz.api.microgrid.v1.microgrid_pb2.GetMicrogridMetadataResponse] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/GetMicrogridMetadata', request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.GetMicrogridMetadataResponse.FromString)</code>  <code>instance-attribute</code>","text":"<p>Returns the microgrid metadata The metadata consists of information that describes the overall microgrid, as opposed to its electrical components or sensors, e.g., the microgrid ID, location.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.ListComponents","title":"<code>ListComponents: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsRequest, frequenz.api.microgrid.v1.microgrid_pb2.ListComponentsResponse] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/ListComponents', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsRequest.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsResponse.FromString)</code>  <code>instance-attribute</code>","text":"<p>List electrical components in the local microgrid, optionally filtered by a given list of component IDs and component categories.</p> <p>Electrical components are a part of a microgrid's electrical infrastructure are can be connected to each other to form an electrical circuit, which can then be represented as a graph.</p> <p>If provided, the filters for component IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [  <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code>,  <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>ComponentCategory::COMPONENT_CATEGORY_INVERTER</code> OR <code>ComponentCategory::COMPONENT_CATEGORY_BATTERY</code>.</p> <p>If a filter list is empty, then that filter is not applied.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.ListConnections","title":"<code>ListConnections: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsRequest, frequenz.api.microgrid.v1.microgrid_pb2.ListConnectionsResponse] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/ListConnections', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsRequest.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsResponse.FromString)</code>  <code>instance-attribute</code>","text":"<p>Electrical components are a part of a microgrid's electrical infrastructure are can be connected to each other to form an electrical circuit, which can then be represented as a graph.</p> <p>This RPC return a list of the connections between two components, denoted by <code>(start, end)</code>. The direction of a connection is always away from the grid endpoint, i.e. aligned with the direction of positive current according to the passive sign convention: https://en.wikipedia.org/wiki/Passive_sign_convention</p> <p>The request may be filtered by <code>start</code>/<code>end</code> component(s) of individual connections.  If provided, the <code>start</code> and <code>end</code> filters have an <code>AND</code> relationship between each other, meaning that they are applied serially, but an <code>OR</code> relationship with other elements in the same list. For example, if <code>start</code> = <code>[1, 2, 3]</code>, and <code>end</code> = <code>[4, 5, 6]</code>, then the result should have all the connections where * each <code>start</code> component ID is either <code>1</code>, <code>2</code>, OR <code>3</code>,  AND * each <code>end</code> component ID is either <code>4</code>, <code>5</code>, OR <code>6</code>.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.ListSensors","title":"<code>ListSensors: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ListSensorRequest, frequenz.api.microgrid.v1.microgrid_pb2.ListSensorsResponse] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/ListSensors', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorRequest.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorsResponse.FromString)</code>  <code>instance-attribute</code>","text":"<p>Returns a list of sensors in the local microgrid, optionally filtered by a given list of sensor IDs and sensor categories.</p> <p>Sensors measure physical metrics in the microgrid's surroundings, and are not classified as electrical components.</p> <p>If provided, the filters for sensor IDs and categories have an <code>AND</code> relationship with one another, meaning that they are applied serially, but the elements within a single filter list have an <code>OR</code> relationship with each other. E.g., if <code>ids</code> = [1, 2, 3], and <code>categories</code> = [  <code>SensorCategory::SENSOR_CATEGORY_THERMOMETER</code>,  <code>SensorCategory::SENSOR_CATEGORY_HYGROMETER</code>], then the results will consist of elements that have the IDs 1, OR 2, OR 3, AND are of the categories <code>SensorCategory::SENSOR_CATEGORY_THERMOMETER</code> OR <code>SensorCategory::SENSOR_CATEGORY_HYGROMETER</code>.</p> <p>If a filter list is empty, then that filter is not applied.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.PutComponentInStandby","title":"<code>PutComponentInStandby: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.PutComponentInStandbyRequest, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/PutComponentInStandby', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.PutComponentInStandbyRequest.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Sets the given component into a standby state, from which it can take a few minutes to return to an operational state. A transition to an operational state can be triggered by calling the <code>StartComponent</code> RPC, or the <code>SetComponentPowerActive</code> RPC.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Checks if AC and DC relays are closed, then</li> <li>sets power to 0, and</li> <li>opens AC relays</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call efffectively skips that action.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.ReceiveComponentDataStream","title":"<code>ReceiveComponentDataStream: grpc.UnaryStreamMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamRequest, frequenz.api.microgrid.v1.microgrid_pb2.ReceiveComponentDataStreamResponse] = channel.unary_stream('/frequenz.api.microgrid.v1.Microgrid/ReceiveComponentDataStream', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamRequest.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamResponse.FromString)</code>  <code>instance-attribute</code>","text":"<p>Returns a stream containing data from a component with a given ID.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.ReceiveSensorDataStream","title":"<code>ReceiveSensorDataStream: grpc.UnaryStreamMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamRequest, frequenz.api.microgrid.v1.microgrid_pb2.ReceiveSensorDataStreamResponse] = channel.unary_stream('/frequenz.api.microgrid.v1.Microgrid/ReceiveSensorDataStream', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamRequest.SerializeToString, response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamResponse.FromString)</code>  <code>instance-attribute</code>","text":"<p>Returns a stream containing data from a sensor with a given ID.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.SetComponentPowerActive","title":"<code>SetComponentPowerActive: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerActiveRequest, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerActive', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveRequest.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Sets the active power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 W. E.g., an inverter may have a resolution of 88 W. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter: Sends the discharge command to the inverter, making it deliver  AC power.</li> </ul>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.SetComponentPowerReactive","title":"<code>SetComponentPowerReactive: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.SetComponentPowerReactiveRequest, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerReactive', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveRequest.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Sets the reactive power output of a component with a given ID, provided the component supports it.</p> <p>Note that the target component may have a resolution of more than 1 VAr. E.g., an inverter may have a resolution of 88 VAr. In such cases, the magnitude of power will be floored to the nearest multiple of the resolution.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.StartComponent","title":"<code>StartComponent: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.StartComponentRequest, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/StartComponent', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StartComponentRequest.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Starts the component, and brings it into a state where it is immediately operational.</p> <p>Performs the following sequence of actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>closes DC relays, if the feature is available</li> <li>closes AC relays</li> <li> <p>sets power output to 0</p> </li> <li> <p>Battery: Checks if DC relays are open, then</p> </li> <li> <p>closes DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>closes relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>starts the precharge process, and eventually closes the DC relays.</li> </ul> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.StopComponent","title":"<code>StopComponent: grpc.UnaryUnaryMultiCallable[frequenz.api.microgrid.v1.microgrid_pb2.StopComponentRequest, google.protobuf.empty_pb2.Empty] = channel.unary_unary('/frequenz.api.microgrid.v1.Microgrid/StopComponent', request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StopComponentRequest.SerializeToString, response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString)</code>  <code>instance-attribute</code>","text":"<p>Stops the component completely, potentially disengaging its power electronics controller(s).</p> <p>Performs the following sequence actions for the following component categories:</p> <ul> <li>Inverter:</li> <li>Brings component to the cold-standby state</li> <li> <p>opens DC relays</p> </li> <li> <p>Battery: Checks if the power output is 0, then</p> </li> <li> <p>opens DC relays</p> </li> <li> <p>Relays:</p> </li> <li> <p>opens relays</p> </li> <li> <p>Precharge Modules:</p> </li> <li>opens the DC relays.</li> </ul> <p>If any of the checks mentioned above fails, then the method call returns an error.</p> <p>If any of the above mentioned actions for a given component has already been performed, then this method call effectively skips that action.</p> <p>If a feature required to perform an action is missing, then that action is skipped.</p>"},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/microgrid/v1/microgrid_pb2_grpc/#frequenz.api.microgrid.v1.microgrid_pb2_grpc.MicrogridStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> PARAMETER  DESCRIPTION <code>channel</code> <p>A grpc.Channel.</p> <p> TYPE: <code>Union[Channel, Channel]</code> </p> Source code in <code>frequenz/api/microgrid/v1/microgrid_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.GetMicrogridMetadata = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/GetMicrogridMetadata',\n            request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.GetMicrogridMetadataResponse.FromString,\n            )\n    self.ListComponents = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/ListComponents',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsResponse.FromString,\n            )\n    self.ListSensors = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/ListSensors',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorsResponse.FromString,\n            )\n    self.ListConnections = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/ListConnections',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsResponse.FromString,\n            )\n    self.ReceiveComponentDataStream = channel.unary_stream(\n            '/frequenz.api.microgrid.v1.Microgrid/ReceiveComponentDataStream',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamResponse.FromString,\n            )\n    self.ReceiveSensorDataStream = channel.unary_stream(\n            '/frequenz.api.microgrid.v1.Microgrid/ReceiveSensorDataStream',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamResponse.FromString,\n            )\n    self.AddComponentExclusionBounds = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/AddComponentExclusionBounds',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsResponse.FromString,\n            )\n    self.AddComponentInclusionBounds = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/AddComponentInclusionBounds',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsResponse.FromString,\n            )\n    self.SetComponentPowerActive = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerActive',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveRequest.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.SetComponentPowerReactive = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerReactive',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveRequest.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.StartComponent = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/StartComponent',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StartComponentRequest.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.PutComponentInStandby = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/PutComponentInStandby',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.PutComponentInStandbyRequest.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.StopComponent = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/StopComponent',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StopComponentRequest.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n    self.AckComponentError = channel.unary_unary(\n            '/frequenz.api.microgrid.v1.Microgrid/AckComponentError',\n            request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AckComponentErrorRequest.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            )\n</code></pre>"}]}